// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Murmur.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Murmur__ServerCallback__userConnected_name = "userConnected";

const ::std::string __Murmur__ServerCallback__userDisconnected_name = "userDisconnected";

const ::std::string __Murmur__ServerCallback__userStateChanged_name = "userStateChanged";

const ::std::string __Murmur__ServerCallback__userTextMessage_name = "userTextMessage";

const ::std::string __Murmur__ServerCallback__channelCreated_name = "channelCreated";

const ::std::string __Murmur__ServerCallback__channelRemoved_name = "channelRemoved";

const ::std::string __Murmur__ServerCallback__channelStateChanged_name = "channelStateChanged";

const ::std::string __Murmur__ServerContextCallback__contextAction_name = "contextAction";

const ::std::string __Murmur__ServerAuthenticator__authenticate_name = "authenticate";

const ::std::string __Murmur__ServerAuthenticator__getInfo_name = "getInfo";

const ::std::string __Murmur__ServerAuthenticator__nameToId_name = "nameToId";

const ::std::string __Murmur__ServerAuthenticator__idToName_name = "idToName";

const ::std::string __Murmur__ServerAuthenticator__idToTexture_name = "idToTexture";

const ::std::string __Murmur__ServerUpdatingAuthenticator__registerUser_name = "registerUser";

const ::std::string __Murmur__ServerUpdatingAuthenticator__unregisterUser_name = "unregisterUser";

const ::std::string __Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name = "getRegisteredUsers";

const ::std::string __Murmur__ServerUpdatingAuthenticator__setInfo_name = "setInfo";

const ::std::string __Murmur__ServerUpdatingAuthenticator__setTexture_name = "setTexture";

const ::std::string __Murmur__Server__isRunning_name = "isRunning";

const ::std::string __Murmur__Server__start_name = "start";

const ::std::string __Murmur__Server__stop_name = "stop";

const ::std::string __Murmur__Server__delete_name = "delete";

const ::std::string __Murmur__Server__id_name = "id";

const ::std::string __Murmur__Server__addCallback_name = "addCallback";

const ::std::string __Murmur__Server__removeCallback_name = "removeCallback";

const ::std::string __Murmur__Server__setAuthenticator_name = "setAuthenticator";

const ::std::string __Murmur__Server__getConf_name = "getConf";

const ::std::string __Murmur__Server__getAllConf_name = "getAllConf";

const ::std::string __Murmur__Server__setConf_name = "setConf";

const ::std::string __Murmur__Server__setSuperuserPassword_name = "setSuperuserPassword";

const ::std::string __Murmur__Server__getLog_name = "getLog";

const ::std::string __Murmur__Server__getLogLen_name = "getLogLen";

const ::std::string __Murmur__Server__getUsers_name = "getUsers";

const ::std::string __Murmur__Server__getChannels_name = "getChannels";

const ::std::string __Murmur__Server__getCertificateList_name = "getCertificateList";

const ::std::string __Murmur__Server__getTree_name = "getTree";

const ::std::string __Murmur__Server__getBans_name = "getBans";

const ::std::string __Murmur__Server__setBans_name = "setBans";

const ::std::string __Murmur__Server__kickUser_name = "kickUser";

const ::std::string __Murmur__Server__getState_name = "getState";

const ::std::string __Murmur__Server__setState_name = "setState";

const ::std::string __Murmur__Server__sendMessage_name = "sendMessage";

const ::std::string __Murmur__Server__hasPermission_name = "hasPermission";

const ::std::string __Murmur__Server__effectivePermissions_name = "effectivePermissions";

const ::std::string __Murmur__Server__addContextCallback_name = "addContextCallback";

const ::std::string __Murmur__Server__removeContextCallback_name = "removeContextCallback";

const ::std::string __Murmur__Server__getChannelState_name = "getChannelState";

const ::std::string __Murmur__Server__setChannelState_name = "setChannelState";

const ::std::string __Murmur__Server__removeChannel_name = "removeChannel";

const ::std::string __Murmur__Server__addChannel_name = "addChannel";

const ::std::string __Murmur__Server__sendMessageChannel_name = "sendMessageChannel";

const ::std::string __Murmur__Server__getACL_name = "getACL";

const ::std::string __Murmur__Server__setACL_name = "setACL";

const ::std::string __Murmur__Server__addUserToGroup_name = "addUserToGroup";

const ::std::string __Murmur__Server__removeUserFromGroup_name = "removeUserFromGroup";

const ::std::string __Murmur__Server__redirectWhisperGroup_name = "redirectWhisperGroup";

const ::std::string __Murmur__Server__getUserNames_name = "getUserNames";

const ::std::string __Murmur__Server__getUserIds_name = "getUserIds";

const ::std::string __Murmur__Server__registerUser_name = "registerUser";

const ::std::string __Murmur__Server__unregisterUser_name = "unregisterUser";

const ::std::string __Murmur__Server__updateRegistration_name = "updateRegistration";

const ::std::string __Murmur__Server__getRegistration_name = "getRegistration";

const ::std::string __Murmur__Server__getRegisteredUsers_name = "getRegisteredUsers";

const ::std::string __Murmur__Server__verifyPassword_name = "verifyPassword";

const ::std::string __Murmur__Server__getTexture_name = "getTexture";

const ::std::string __Murmur__Server__setTexture_name = "setTexture";

const ::std::string __Murmur__Server__getUptime_name = "getUptime";

const ::std::string __Murmur__MetaCallback__started_name = "started";

const ::std::string __Murmur__MetaCallback__stopped_name = "stopped";

const ::std::string __Murmur__Meta__getServer_name = "getServer";

const ::std::string __Murmur__Meta__newServer_name = "newServer";

const ::std::string __Murmur__Meta__getBootedServers_name = "getBootedServers";

const ::std::string __Murmur__Meta__getAllServers_name = "getAllServers";

const ::std::string __Murmur__Meta__getDefaultConf_name = "getDefaultConf";

const ::std::string __Murmur__Meta__getVersion_name = "getVersion";

const ::std::string __Murmur__Meta__addCallback_name = "addCallback";

const ::std::string __Murmur__Meta__removeCallback_name = "removeCallback";

const ::std::string __Murmur__Meta__getUptime_name = "getUptime";

const ::std::string __Murmur__Meta__getSlice_name = "getSlice";

const ::std::string __Murmur__Meta__getSliceChecksums_name = "getSliceChecksums";

}

namespace
{

const char* __Murmur__MurmurException_name = "Murmur::MurmurException";

struct __F__Murmur__MurmurException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::MurmurException();
    }
};

class __F__Murmur__MurmurException__Init
{
public:

    __F__Murmur__MurmurException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::MurmurException", new __F__Murmur__MurmurException);
    }

    ~__F__Murmur__MurmurException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::MurmurException");
    }
};

const __F__Murmur__MurmurException__Init __F__Murmur__MurmurException__i;

}

Murmur::MurmurException::~MurmurException() throw()
{
}

::std::string
Murmur::MurmurException::ice_name() const
{
    return __Murmur__MurmurException_name;
}

Murmur::MurmurException*
Murmur::MurmurException::ice_clone() const
{
    return new MurmurException(*this);
}

void
Murmur::MurmurException::ice_throw() const
{
    throw *this;
}

void
Murmur::MurmurException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::MurmurException", -1, true);
    __os->endWriteSlice();
}

void
Murmur::MurmurException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Murmur__InvalidSessionException_name = "Murmur::InvalidSessionException";

struct __F__Murmur__InvalidSessionException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidSessionException();
    }
};

class __F__Murmur__InvalidSessionException__Init
{
public:

    __F__Murmur__InvalidSessionException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidSessionException", new __F__Murmur__InvalidSessionException);
    }

    ~__F__Murmur__InvalidSessionException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidSessionException");
    }
};

const __F__Murmur__InvalidSessionException__Init __F__Murmur__InvalidSessionException__i;

}

Murmur::InvalidSessionException::~InvalidSessionException() throw()
{
}

::std::string
Murmur::InvalidSessionException::ice_name() const
{
    return __Murmur__InvalidSessionException_name;
}

Murmur::InvalidSessionException*
Murmur::InvalidSessionException::ice_clone() const
{
    return new InvalidSessionException(*this);
}

void
Murmur::InvalidSessionException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidSessionException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidSessionException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidSessionException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__InvalidChannelException_name = "Murmur::InvalidChannelException";

struct __F__Murmur__InvalidChannelException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidChannelException();
    }
};

class __F__Murmur__InvalidChannelException__Init
{
public:

    __F__Murmur__InvalidChannelException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidChannelException", new __F__Murmur__InvalidChannelException);
    }

    ~__F__Murmur__InvalidChannelException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidChannelException");
    }
};

const __F__Murmur__InvalidChannelException__Init __F__Murmur__InvalidChannelException__i;

}

Murmur::InvalidChannelException::~InvalidChannelException() throw()
{
}

::std::string
Murmur::InvalidChannelException::ice_name() const
{
    return __Murmur__InvalidChannelException_name;
}

Murmur::InvalidChannelException*
Murmur::InvalidChannelException::ice_clone() const
{
    return new InvalidChannelException(*this);
}

void
Murmur::InvalidChannelException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidChannelException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidChannelException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidChannelException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__InvalidServerException_name = "Murmur::InvalidServerException";

struct __F__Murmur__InvalidServerException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidServerException();
    }
};

class __F__Murmur__InvalidServerException__Init
{
public:

    __F__Murmur__InvalidServerException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidServerException", new __F__Murmur__InvalidServerException);
    }

    ~__F__Murmur__InvalidServerException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidServerException");
    }
};

const __F__Murmur__InvalidServerException__Init __F__Murmur__InvalidServerException__i;

}

Murmur::InvalidServerException::~InvalidServerException() throw()
{
}

::std::string
Murmur::InvalidServerException::ice_name() const
{
    return __Murmur__InvalidServerException_name;
}

Murmur::InvalidServerException*
Murmur::InvalidServerException::ice_clone() const
{
    return new InvalidServerException(*this);
}

void
Murmur::InvalidServerException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidServerException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidServerException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidServerException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__ServerBootedException_name = "Murmur::ServerBootedException";

struct __F__Murmur__ServerBootedException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::ServerBootedException();
    }
};

class __F__Murmur__ServerBootedException__Init
{
public:

    __F__Murmur__ServerBootedException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::ServerBootedException", new __F__Murmur__ServerBootedException);
    }

    ~__F__Murmur__ServerBootedException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::ServerBootedException");
    }
};

const __F__Murmur__ServerBootedException__Init __F__Murmur__ServerBootedException__i;

}

Murmur::ServerBootedException::~ServerBootedException() throw()
{
}

::std::string
Murmur::ServerBootedException::ice_name() const
{
    return __Murmur__ServerBootedException_name;
}

Murmur::ServerBootedException*
Murmur::ServerBootedException::ice_clone() const
{
    return new ServerBootedException(*this);
}

void
Murmur::ServerBootedException::ice_throw() const
{
    throw *this;
}

void
Murmur::ServerBootedException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::ServerBootedException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::ServerBootedException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__ServerFailureException_name = "Murmur::ServerFailureException";

struct __F__Murmur__ServerFailureException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::ServerFailureException();
    }
};

class __F__Murmur__ServerFailureException__Init
{
public:

    __F__Murmur__ServerFailureException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::ServerFailureException", new __F__Murmur__ServerFailureException);
    }

    ~__F__Murmur__ServerFailureException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::ServerFailureException");
    }
};

const __F__Murmur__ServerFailureException__Init __F__Murmur__ServerFailureException__i;

}

Murmur::ServerFailureException::~ServerFailureException() throw()
{
}

::std::string
Murmur::ServerFailureException::ice_name() const
{
    return __Murmur__ServerFailureException_name;
}

Murmur::ServerFailureException*
Murmur::ServerFailureException::ice_clone() const
{
    return new ServerFailureException(*this);
}

void
Murmur::ServerFailureException::ice_throw() const
{
    throw *this;
}

void
Murmur::ServerFailureException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::ServerFailureException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::ServerFailureException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__InvalidUserException_name = "Murmur::InvalidUserException";

struct __F__Murmur__InvalidUserException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidUserException();
    }
};

class __F__Murmur__InvalidUserException__Init
{
public:

    __F__Murmur__InvalidUserException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidUserException", new __F__Murmur__InvalidUserException);
    }

    ~__F__Murmur__InvalidUserException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidUserException");
    }
};

const __F__Murmur__InvalidUserException__Init __F__Murmur__InvalidUserException__i;

}

Murmur::InvalidUserException::~InvalidUserException() throw()
{
}

::std::string
Murmur::InvalidUserException::ice_name() const
{
    return __Murmur__InvalidUserException_name;
}

Murmur::InvalidUserException*
Murmur::InvalidUserException::ice_clone() const
{
    return new InvalidUserException(*this);
}

void
Murmur::InvalidUserException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidUserException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidUserException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidUserException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__InvalidTextureException_name = "Murmur::InvalidTextureException";

struct __F__Murmur__InvalidTextureException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidTextureException();
    }
};

class __F__Murmur__InvalidTextureException__Init
{
public:

    __F__Murmur__InvalidTextureException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidTextureException", new __F__Murmur__InvalidTextureException);
    }

    ~__F__Murmur__InvalidTextureException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidTextureException");
    }
};

const __F__Murmur__InvalidTextureException__Init __F__Murmur__InvalidTextureException__i;

}

Murmur::InvalidTextureException::~InvalidTextureException() throw()
{
}

::std::string
Murmur::InvalidTextureException::ice_name() const
{
    return __Murmur__InvalidTextureException_name;
}

Murmur::InvalidTextureException*
Murmur::InvalidTextureException::ice_clone() const
{
    return new InvalidTextureException(*this);
}

void
Murmur::InvalidTextureException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidTextureException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidTextureException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidTextureException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__InvalidCallbackException_name = "Murmur::InvalidCallbackException";

struct __F__Murmur__InvalidCallbackException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidCallbackException();
    }
};

class __F__Murmur__InvalidCallbackException__Init
{
public:

    __F__Murmur__InvalidCallbackException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidCallbackException", new __F__Murmur__InvalidCallbackException);
    }

    ~__F__Murmur__InvalidCallbackException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidCallbackException");
    }
};

const __F__Murmur__InvalidCallbackException__Init __F__Murmur__InvalidCallbackException__i;

}

Murmur::InvalidCallbackException::~InvalidCallbackException() throw()
{
}

::std::string
Murmur::InvalidCallbackException::ice_name() const
{
    return __Murmur__InvalidCallbackException_name;
}

Murmur::InvalidCallbackException*
Murmur::InvalidCallbackException::ice_clone() const
{
    return new InvalidCallbackException(*this);
}

void
Murmur::InvalidCallbackException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidCallbackException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidCallbackException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidCallbackException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__InvalidSecretException_name = "Murmur::InvalidSecretException";

struct __F__Murmur__InvalidSecretException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::InvalidSecretException();
    }
};

class __F__Murmur__InvalidSecretException__Init
{
public:

    __F__Murmur__InvalidSecretException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::InvalidSecretException", new __F__Murmur__InvalidSecretException);
    }

    ~__F__Murmur__InvalidSecretException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::InvalidSecretException");
    }
};

const __F__Murmur__InvalidSecretException__Init __F__Murmur__InvalidSecretException__i;

}

Murmur::InvalidSecretException::~InvalidSecretException() throw()
{
}

::std::string
Murmur::InvalidSecretException::ice_name() const
{
    return __Murmur__InvalidSecretException_name;
}

Murmur::InvalidSecretException*
Murmur::InvalidSecretException::ice_clone() const
{
    return new InvalidSecretException(*this);
}

void
Murmur::InvalidSecretException::ice_throw() const
{
    throw *this;
}

void
Murmur::InvalidSecretException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::InvalidSecretException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::InvalidSecretException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__NestingLimitException_name = "Murmur::NestingLimitException";

struct __F__Murmur__NestingLimitException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::NestingLimitException();
    }
};

class __F__Murmur__NestingLimitException__Init
{
public:

    __F__Murmur__NestingLimitException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::NestingLimitException", new __F__Murmur__NestingLimitException);
    }

    ~__F__Murmur__NestingLimitException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::NestingLimitException");
    }
};

const __F__Murmur__NestingLimitException__Init __F__Murmur__NestingLimitException__i;

}

Murmur::NestingLimitException::~NestingLimitException() throw()
{
}

::std::string
Murmur::NestingLimitException::ice_name() const
{
    return __Murmur__NestingLimitException_name;
}

Murmur::NestingLimitException*
Murmur::NestingLimitException::ice_clone() const
{
    return new NestingLimitException(*this);
}

void
Murmur::NestingLimitException::ice_throw() const
{
    throw *this;
}

void
Murmur::NestingLimitException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::NestingLimitException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::NestingLimitException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace
{

const char* __Murmur__WriteOnlyException_name = "Murmur::WriteOnlyException";

struct __F__Murmur__WriteOnlyException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Murmur::WriteOnlyException();
    }
};

class __F__Murmur__WriteOnlyException__Init
{
public:

    __F__Murmur__WriteOnlyException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Murmur::WriteOnlyException", new __F__Murmur__WriteOnlyException);
    }

    ~__F__Murmur__WriteOnlyException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Murmur::WriteOnlyException");
    }
};

const __F__Murmur__WriteOnlyException__Init __F__Murmur__WriteOnlyException__i;

}

Murmur::WriteOnlyException::~WriteOnlyException() throw()
{
}

::std::string
Murmur::WriteOnlyException::ice_name() const
{
    return __Murmur__WriteOnlyException_name;
}

Murmur::WriteOnlyException*
Murmur::WriteOnlyException::ice_clone() const
{
    return new WriteOnlyException(*this);
}

void
Murmur::WriteOnlyException::ice_throw() const
{
    throw *this;
}

void
Murmur::WriteOnlyException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Murmur::WriteOnlyException", -1, false);
    __os->endWriteSlice();
    ::Murmur::MurmurException::__writeImpl(__os);
}

void
Murmur::WriteOnlyException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::Murmur::MurmurException::__readImpl(__is);
}

namespace Ice
{
}

IceAsync::Murmur::AMD_Server_isRunning::AMD_Server_isRunning(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_isRunning::ice_response(bool __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_isRunning::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_start::AMD_Server_start(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_start::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_start::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerFailureException* __ex = dynamic_cast<const ::Murmur::ServerFailureException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_stop::AMD_Server_stop(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_stop::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_stop::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_delete::AMD_Server_delete(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_delete::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_delete::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_id::AMD_Server_id(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_id::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_id::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_addCallback::AMD_Server_addCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addCallback::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_addCallback::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_removeCallback::AMD_Server_removeCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeCallback::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_removeCallback::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setAuthenticator::AMD_Server_setAuthenticator(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setAuthenticator::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setAuthenticator::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getConf::AMD_Server_getConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getConf::ice_response(const ::std::string& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getConf::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::WriteOnlyException* __ex = dynamic_cast<const ::Murmur::WriteOnlyException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getAllConf::AMD_Server_getAllConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getAllConf::ice_response(const ::Murmur::ConfigMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getAllConf::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setConf::AMD_Server_setConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setConf::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setConf::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setSuperuserPassword::AMD_Server_setSuperuserPassword(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setSuperuserPassword::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setSuperuserPassword::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getLog::AMD_Server_getLog(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getLog::ice_response(const ::Murmur::LogList& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getLog::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getLogLen::AMD_Server_getLogLen(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getLogLen::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getLogLen::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getUsers::AMD_Server_getUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUsers::ice_response(const ::Murmur::UserMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getUsers::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getChannels::AMD_Server_getChannels(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getChannels::ice_response(const ::Murmur::ChannelMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getChannels::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getCertificateList::AMD_Server_getCertificateList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getCertificateList::ice_response(const ::Murmur::CertificateList& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getCertificateList::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getTree::AMD_Server_getTree(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getTree::ice_response(const ::Murmur::TreePtr& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __os->writePendingObjects();
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getTree::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getBans::AMD_Server_getBans(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getBans::ice_response(const ::Murmur::BanList& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getBans::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setBans::AMD_Server_setBans(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setBans::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setBans::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_kickUser::AMD_Server_kickUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_kickUser::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_kickUser::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getState::AMD_Server_getState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getState::ice_response(const ::Murmur::User& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getState::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setState::AMD_Server_setState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setState::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setState::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_sendMessage::AMD_Server_sendMessage(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_sendMessage::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_sendMessage::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_hasPermission::AMD_Server_hasPermission(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_hasPermission::ice_response(bool __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_hasPermission::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_effectivePermissions::AMD_Server_effectivePermissions(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_effectivePermissions::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_effectivePermissions::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_addContextCallback::AMD_Server_addContextCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addContextCallback::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_addContextCallback::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_removeContextCallback::AMD_Server_removeContextCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeContextCallback::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_removeContextCallback::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getChannelState::AMD_Server_getChannelState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getChannelState::ice_response(const ::Murmur::Channel& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getChannelState::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setChannelState::AMD_Server_setChannelState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setChannelState::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setChannelState::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::NestingLimitException* __ex = dynamic_cast<const ::Murmur::NestingLimitException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_removeChannel::AMD_Server_removeChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeChannel::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_removeChannel::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_addChannel::AMD_Server_addChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addChannel::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_addChannel::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::NestingLimitException* __ex = dynamic_cast<const ::Murmur::NestingLimitException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_sendMessageChannel::AMD_Server_sendMessageChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_sendMessageChannel::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_sendMessageChannel::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getACL::AMD_Server_getACL(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getACL::ice_response(const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(acls);
            __os->write(groups);
            __os->write(inherit);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getACL::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setACL::AMD_Server_setACL(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setACL::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setACL::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_addUserToGroup::AMD_Server_addUserToGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addUserToGroup::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_addUserToGroup::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_removeUserFromGroup::AMD_Server_removeUserFromGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeUserFromGroup::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_removeUserFromGroup::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidChannelException* __ex = dynamic_cast<const ::Murmur::InvalidChannelException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_redirectWhisperGroup::AMD_Server_redirectWhisperGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_redirectWhisperGroup::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_redirectWhisperGroup::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSessionException* __ex = dynamic_cast<const ::Murmur::InvalidSessionException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getUserNames::AMD_Server_getUserNames(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUserNames::ice_response(const ::Murmur::NameMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getUserNames::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getUserIds::AMD_Server_getUserIds(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUserIds::ice_response(const ::Murmur::IdMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getUserIds::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_registerUser::AMD_Server_registerUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_registerUser::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_registerUser::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidUserException* __ex = dynamic_cast<const ::Murmur::InvalidUserException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_unregisterUser::AMD_Server_unregisterUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_unregisterUser::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_unregisterUser::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidUserException* __ex = dynamic_cast<const ::Murmur::InvalidUserException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_updateRegistration::AMD_Server_updateRegistration(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_updateRegistration::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_updateRegistration::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidUserException* __ex = dynamic_cast<const ::Murmur::InvalidUserException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getRegistration::AMD_Server_getRegistration(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getRegistration::ice_response(const ::Murmur::UserInfoMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getRegistration::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidUserException* __ex = dynamic_cast<const ::Murmur::InvalidUserException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getRegisteredUsers::AMD_Server_getRegisteredUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getRegisteredUsers::ice_response(const ::Murmur::NameMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getRegisteredUsers::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_verifyPassword::AMD_Server_verifyPassword(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_verifyPassword::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_verifyPassword::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getTexture::AMD_Server_getTexture(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getTexture::ice_response(const ::Murmur::Texture& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getTexture::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidUserException* __ex = dynamic_cast<const ::Murmur::InvalidUserException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_setTexture::AMD_Server_setTexture(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setTexture::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_setTexture::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidTextureException* __ex = dynamic_cast<const ::Murmur::InvalidTextureException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidUserException* __ex = dynamic_cast<const ::Murmur::InvalidUserException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Server_getUptime::AMD_Server_getUptime(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUptime::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Server_getUptime::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::ServerBootedException* __ex = dynamic_cast<const ::Murmur::ServerBootedException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_getServer::AMD_Meta_getServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getServer::ice_response(const ::Murmur::ServerPrx& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_getServer::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_newServer::AMD_Meta_newServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_newServer::ice_response(const ::Murmur::ServerPrx& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_newServer::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_getBootedServers::AMD_Meta_getBootedServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getBootedServers::ice_response(const ::Murmur::ServerList& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_getBootedServers::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_getAllServers::AMD_Meta_getAllServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getAllServers::ice_response(const ::Murmur::ServerList& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_getAllServers::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_getDefaultConf::AMD_Meta_getDefaultConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getDefaultConf::ice_response(const ::Murmur::ConfigMap& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_getDefaultConf::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_getVersion::AMD_Meta_getVersion(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getVersion::ice_response(::Ice::Int major, ::Ice::Int minor, ::Ice::Int patch, const ::std::string& text)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(major);
            __os->write(minor);
            __os->write(patch);
            __os->write(text);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Murmur::AMD_Meta_addCallback::AMD_Meta_addCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_addCallback::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_addCallback::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_removeCallback::AMD_Meta_removeCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_removeCallback::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::Murmur::AMD_Meta_removeCallback::ice_exception(const ::std::exception& ex)
{
    if(const ::Murmur::InvalidCallbackException* __ex = dynamic_cast<const ::Murmur::InvalidCallbackException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else if(const ::Murmur::InvalidSecretException* __ex = dynamic_cast<const ::Murmur::InvalidSecretException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::Murmur::AMD_Meta_getUptime::AMD_Meta_getUptime(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getUptime::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Murmur::AMD_Meta_getSlice::AMD_Meta_getSlice(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getSlice::ice_response(const ::std::string& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::Murmur::AMD_Meta_getSliceChecksums::AMD_Meta_getSliceChecksums(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getSliceChecksums::ice_response(const ::Ice::SliceChecksumDict& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::Tree* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::Tree>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::Tree;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::Murmur::Tree::ice_staticId()
{
    return ::Murmur::Tree::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::Tree::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::Tree);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::Tree::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::Tree);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::Tree::__newInstance() const
{
    return new Tree;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::ServerCallback* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::ServerCallback;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Murmur::ServerCallback::userConnected(const ::Murmur::User& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__userConnected_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->userConnected(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_userConnected(const ::Murmur::User& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__userConnected_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__userConnected_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_userConnected(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__userConnected_name);
}

void
IceProxy::Murmur::ServerCallback::userDisconnected(const ::Murmur::User& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__userDisconnected_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->userDisconnected(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_userDisconnected(const ::Murmur::User& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__userDisconnected_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__userDisconnected_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_userDisconnected(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__userDisconnected_name);
}

void
IceProxy::Murmur::ServerCallback::userStateChanged(const ::Murmur::User& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__userStateChanged_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->userStateChanged(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_userStateChanged(const ::Murmur::User& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__userStateChanged_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__userStateChanged_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_userStateChanged(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__userStateChanged_name);
}

void
IceProxy::Murmur::ServerCallback::userTextMessage(const ::Murmur::User& state, const ::Murmur::TextMessage& message, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__userTextMessage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->userTextMessage(state, message, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_userTextMessage(const ::Murmur::User& state, const ::Murmur::TextMessage& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__userTextMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__userTextMessage_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __os->write(message);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_userTextMessage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__userTextMessage_name);
}

void
IceProxy::Murmur::ServerCallback::channelCreated(const ::Murmur::Channel& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__channelCreated_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->channelCreated(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_channelCreated(const ::Murmur::Channel& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__channelCreated_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__channelCreated_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_channelCreated(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__channelCreated_name);
}

void
IceProxy::Murmur::ServerCallback::channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__channelRemoved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->channelRemoved(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__channelRemoved_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__channelRemoved_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_channelRemoved(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__channelRemoved_name);
}

void
IceProxy::Murmur::ServerCallback::channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerCallback__channelStateChanged_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerCallback*>(__delBase.get());
            __del->channelStateChanged(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::begin_channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerCallback__channelStateChanged_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerCallback__channelStateChanged_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerCallback::end_channelStateChanged(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerCallback__channelStateChanged_name);
}

const ::std::string&
IceProxy::Murmur::ServerCallback::ice_staticId()
{
    return ::Murmur::ServerCallback::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::ServerCallback::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::ServerCallback);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::ServerCallback::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::ServerCallback);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::ServerCallback::__newInstance() const
{
    return new ServerCallback;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::ServerContextCallback* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerContextCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::ServerContextCallback;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Murmur::ServerContextCallback::contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerContextCallback__contextAction_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerContextCallback* __del = dynamic_cast< ::IceDelegate::Murmur::ServerContextCallback*>(__delBase.get());
            __del->contextAction(action, usr, session, channelid, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerContextCallback::begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerContextCallback__contextAction_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerContextCallback__contextAction_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(action);
        __os->write(usr);
        __os->write(session);
        __os->write(channelid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::ServerContextCallback::end_contextAction(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__ServerContextCallback__contextAction_name);
}

const ::std::string&
IceProxy::Murmur::ServerContextCallback::ice_staticId()
{
    return ::Murmur::ServerContextCallback::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::ServerContextCallback::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::ServerContextCallback);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::ServerContextCallback::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::ServerContextCallback);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::ServerContextCallback::__newInstance() const
{
    return new ServerContextCallback;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::ServerAuthenticator* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerAuthenticator>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::ServerAuthenticator;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::Murmur::ServerAuthenticator::authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, ::std::string& newname, ::Murmur::GroupNameList& groups, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerAuthenticator__authenticate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerAuthenticator__authenticate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerAuthenticator*>(__delBase.get());
            return __del->authenticate(name, pw, certificates, certhash, certstrong, newname, groups, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerAuthenticator__authenticate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerAuthenticator__authenticate_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerAuthenticator__authenticate_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(pw);
        __os->write(certificates);
        __os->write(certhash);
        __os->write(certstrong);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::ServerAuthenticator::end_authenticate(::std::string& newname, ::Murmur::GroupNameList& groups, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerAuthenticator__authenticate_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(newname);
        __is->read(groups);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Murmur::ServerAuthenticator::getInfo(::Ice::Int id, ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerAuthenticator__getInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerAuthenticator__getInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerAuthenticator*>(__delBase.get());
            return __del->getInfo(id, info, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::begin_getInfo(::Ice::Int id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerAuthenticator__getInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerAuthenticator__getInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerAuthenticator__getInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Murmur::ServerAuthenticator::end_getInfo(::Murmur::UserInfoMap& info, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerAuthenticator__getInfo_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(info);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::ServerAuthenticator::nameToId(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerAuthenticator__nameToId_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerAuthenticator__nameToId_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerAuthenticator*>(__delBase.get());
            return __del->nameToId(name, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::begin_nameToId(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerAuthenticator__nameToId_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerAuthenticator__nameToId_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerAuthenticator__nameToId_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::ServerAuthenticator::end_nameToId(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerAuthenticator__nameToId_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::std::string
IceProxy::Murmur::ServerAuthenticator::idToName(::Ice::Int id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerAuthenticator__idToName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerAuthenticator__idToName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerAuthenticator*>(__delBase.get());
            return __del->idToName(id, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::begin_idToName(::Ice::Int id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerAuthenticator__idToName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerAuthenticator__idToName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerAuthenticator__idToName_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Murmur::ServerAuthenticator::end_idToName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerAuthenticator__idToName_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::Texture
IceProxy::Murmur::ServerAuthenticator::idToTexture(::Ice::Int id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerAuthenticator__idToTexture_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerAuthenticator__idToTexture_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerAuthenticator*>(__delBase.get());
            return __del->idToTexture(id, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::begin_idToTexture(::Ice::Int id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerAuthenticator__idToTexture_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerAuthenticator__idToTexture_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerAuthenticator__idToTexture_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::Texture
IceProxy::Murmur::ServerAuthenticator::end_idToTexture(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerAuthenticator__idToTexture_name);
    ::Murmur::Texture __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Murmur::ServerAuthenticator::ice_staticId()
{
    return ::Murmur::ServerAuthenticator::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::ServerAuthenticator::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::ServerAuthenticator);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::ServerAuthenticator::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::ServerAuthenticator);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::ServerAuthenticator::__newInstance() const
{
    return new ServerAuthenticator;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::ServerUpdatingAuthenticator* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerUpdatingAuthenticator>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::ServerUpdatingAuthenticator;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerUpdatingAuthenticator__registerUser_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerUpdatingAuthenticator__registerUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerUpdatingAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerUpdatingAuthenticator*>(__delBase.get());
            return __del->registerUser(info, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerUpdatingAuthenticator__registerUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerUpdatingAuthenticator__registerUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerUpdatingAuthenticator__registerUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_registerUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerUpdatingAuthenticator__registerUser_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::unregisterUser(::Ice::Int id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerUpdatingAuthenticator__unregisterUser_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerUpdatingAuthenticator__unregisterUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerUpdatingAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerUpdatingAuthenticator*>(__delBase.get());
            return __del->unregisterUser(id, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::begin_unregisterUser(::Ice::Int id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerUpdatingAuthenticator__unregisterUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerUpdatingAuthenticator__unregisterUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerUpdatingAuthenticator__unregisterUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_unregisterUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerUpdatingAuthenticator__unregisterUser_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::NameMap
IceProxy::Murmur::ServerUpdatingAuthenticator::getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerUpdatingAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerUpdatingAuthenticator*>(__delBase.get());
            return __del->getRegisteredUsers(filter, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(filter);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::NameMap
IceProxy::Murmur::ServerUpdatingAuthenticator::end_getRegisteredUsers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name);
    ::Murmur::NameMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerUpdatingAuthenticator__setInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerUpdatingAuthenticator__setInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerUpdatingAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerUpdatingAuthenticator*>(__delBase.get());
            return __del->setInfo(id, info, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerUpdatingAuthenticator__setInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerUpdatingAuthenticator__setInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerUpdatingAuthenticator__setInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_setInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerUpdatingAuthenticator__setInfo_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__ServerUpdatingAuthenticator__setTexture_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__ServerUpdatingAuthenticator__setTexture_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::ServerUpdatingAuthenticator* __del = dynamic_cast< ::IceDelegate::Murmur::ServerUpdatingAuthenticator*>(__delBase.get());
            return __del->setTexture(id, tex, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__ServerUpdatingAuthenticator__setTexture_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__ServerUpdatingAuthenticator__setTexture_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__ServerUpdatingAuthenticator__setTexture_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __os->write(tex);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_setTexture(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__ServerUpdatingAuthenticator__setTexture_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Murmur::ServerUpdatingAuthenticator::ice_staticId()
{
    return ::Murmur::ServerUpdatingAuthenticator::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::ServerUpdatingAuthenticator::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::ServerUpdatingAuthenticator);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::ServerUpdatingAuthenticator::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::ServerUpdatingAuthenticator);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::ServerUpdatingAuthenticator::__newInstance() const
{
    return new ServerUpdatingAuthenticator;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::Server* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::Server>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::Server;
        v->__copyFrom(proxy);
    }
}

bool
IceProxy::Murmur::Server::isRunning(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__isRunning_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__isRunning_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->isRunning(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_isRunning(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__isRunning_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__isRunning_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__isRunning_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Murmur::Server::end_isRunning(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__isRunning_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::start(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__start_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__start_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->start(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_start(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__start_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__start_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__start_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_start(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__start_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerFailureException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::stop(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__stop_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__stop_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->stop(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_stop(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__stop_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__stop_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__stop_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_stop(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__stop_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::_cpp_delete(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__delete_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__delete_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->_cpp_delete(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_delete(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__delete_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__delete_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__delete_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_delete(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__delete_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::id(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__id_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__id_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->id(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_id(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__id_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__id_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__id_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_id(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__id_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__addCallback_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__addCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->addCallback(cb, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__addCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__addCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__addCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_addCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__addCallback_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__removeCallback_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__removeCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->removeCallback(cb, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__removeCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__removeCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__removeCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_removeCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__removeCallback_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setAuthenticator_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setAuthenticator_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setAuthenticator(auth, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setAuthenticator_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setAuthenticator_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setAuthenticator_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(auth);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setAuthenticator(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setAuthenticator_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::std::string
IceProxy::Murmur::Server::getConf(const ::std::string& key, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getConf_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getConf_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getConf(key, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getConf(const ::std::string& key, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getConf_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getConf_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getConf_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(key);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Murmur::Server::end_getConf(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getConf_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::WriteOnlyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::ConfigMap
IceProxy::Murmur::Server::getAllConf(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getAllConf_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getAllConf_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getAllConf(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getAllConf(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getAllConf_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getAllConf_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getAllConf_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ConfigMap
IceProxy::Murmur::Server::end_getAllConf(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getAllConf_name);
    ::Murmur::ConfigMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setConf_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setConf_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setConf(key, value, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setConf_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setConf_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setConf_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(key);
        __os->write(value);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setConf(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setConf_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setSuperuserPassword(const ::std::string& pw, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setSuperuserPassword_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setSuperuserPassword_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setSuperuserPassword(pw, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setSuperuserPassword(const ::std::string& pw, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setSuperuserPassword_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setSuperuserPassword_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setSuperuserPassword_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(pw);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setSuperuserPassword(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setSuperuserPassword_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::LogList
IceProxy::Murmur::Server::getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getLog_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getLog_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getLog(first, last, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getLog_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getLog_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getLog_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(first);
        __os->write(last);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::LogList
IceProxy::Murmur::Server::end_getLog(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getLog_name);
    ::Murmur::LogList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::getLogLen(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getLogLen_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getLogLen_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getLogLen(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getLogLen(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getLogLen_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getLogLen_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getLogLen_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_getLogLen(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getLogLen_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::UserMap
IceProxy::Murmur::Server::getUsers(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getUsers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getUsers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getUsers(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getUsers(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getUsers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getUsers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getUsers_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::UserMap
IceProxy::Murmur::Server::end_getUsers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getUsers_name);
    ::Murmur::UserMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::ChannelMap
IceProxy::Murmur::Server::getChannels(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getChannels_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getChannels_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getChannels(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getChannels(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getChannels_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getChannels_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getChannels_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ChannelMap
IceProxy::Murmur::Server::end_getChannels(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getChannels_name);
    ::Murmur::ChannelMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::CertificateList
IceProxy::Murmur::Server::getCertificateList(::Ice::Int session, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getCertificateList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getCertificateList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getCertificateList(session, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getCertificateList(::Ice::Int session, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getCertificateList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getCertificateList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getCertificateList_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::CertificateList
IceProxy::Murmur::Server::end_getCertificateList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getCertificateList_name);
    ::Murmur::CertificateList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::TreePtr
IceProxy::Murmur::Server::getTree(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getTree_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getTree_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getTree(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getTree(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getTree_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getTree_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getTree_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::TreePtr
IceProxy::Murmur::Server::end_getTree(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getTree_name);
    ::Murmur::TreePtr __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::BanList
IceProxy::Murmur::Server::getBans(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getBans_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getBans_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getBans(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getBans(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getBans_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getBans_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getBans_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::BanList
IceProxy::Murmur::Server::end_getBans(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getBans_name);
    ::Murmur::BanList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setBans(const ::Murmur::BanList& bans, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setBans_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setBans_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setBans(bans, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setBans(const ::Murmur::BanList& bans, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setBans_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setBans_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setBans_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(bans);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setBans(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setBans_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__kickUser_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__kickUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->kickUser(session, reason, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__kickUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__kickUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__kickUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(reason);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_kickUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__kickUser_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::User
IceProxy::Murmur::Server::getState(::Ice::Int session, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getState_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getState(session, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getState(::Ice::Int session, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getState_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getState_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::User
IceProxy::Murmur::Server::end_getState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getState_name);
    ::Murmur::User __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setState(const ::Murmur::User& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setState_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setState(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setState(const ::Murmur::User& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setState_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setState_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setState_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__sendMessage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__sendMessage_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->sendMessage(session, text, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__sendMessage_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__sendMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__sendMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(text);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_sendMessage(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__sendMessage_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::Murmur::Server::hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__hasPermission_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__hasPermission_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->hasPermission(session, channelid, perm, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__hasPermission_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__hasPermission_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__hasPermission_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(channelid);
        __os->write(perm);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Murmur::Server::end_hasPermission(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__hasPermission_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::effectivePermissions(::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__effectivePermissions_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__effectivePermissions_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->effectivePermissions(session, channelid, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_effectivePermissions(::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__effectivePermissions_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__effectivePermissions_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__effectivePermissions_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(channelid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_effectivePermissions(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__effectivePermissions_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__addContextCallback_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__addContextCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->addContextCallback(session, action, text, cb, ctx, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__addContextCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__addContextCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__addContextCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(action);
        __os->write(text);
        __os->write(cb);
        __os->write(ctx);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_addContextCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__addContextCallback_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__removeContextCallback_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__removeContextCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->removeContextCallback(cb, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__removeContextCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__removeContextCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__removeContextCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_removeContextCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__removeContextCallback_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::Channel
IceProxy::Murmur::Server::getChannelState(::Ice::Int channelid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getChannelState_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getChannelState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getChannelState(channelid, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getChannelState(::Ice::Int channelid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getChannelState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getChannelState_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getChannelState_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::Channel
IceProxy::Murmur::Server::end_getChannelState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getChannelState_name);
    ::Murmur::Channel __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setChannelState(const ::Murmur::Channel& state, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setChannelState_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setChannelState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setChannelState(state, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setChannelState(const ::Murmur::Channel& state, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setChannelState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setChannelState_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setChannelState_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setChannelState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setChannelState_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::NestingLimitException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::removeChannel(::Ice::Int channelid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__removeChannel_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__removeChannel_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->removeChannel(channelid, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_removeChannel(::Ice::Int channelid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__removeChannel_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__removeChannel_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__removeChannel_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_removeChannel(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__removeChannel_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__addChannel_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__addChannel_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->addChannel(name, parent, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__addChannel_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__addChannel_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__addChannel_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(parent);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_addChannel(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__addChannel_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::NestingLimitException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__sendMessageChannel_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__sendMessageChannel_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->sendMessageChannel(channelid, tree, text, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__sendMessageChannel_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__sendMessageChannel_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__sendMessageChannel_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(tree);
        __os->write(text);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_sendMessageChannel(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__sendMessageChannel_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::getACL(::Ice::Int channelid, ::Murmur::ACLList& acls, ::Murmur::GroupList& groups, bool& inherit, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getACL_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getACL_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->getACL(channelid, acls, groups, inherit, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getACL(::Ice::Int channelid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getACL_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getACL_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getACL_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_getACL(::Murmur::ACLList& acls, ::Murmur::GroupList& groups, bool& inherit, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getACL_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(acls);
        __is->read(groups);
        __is->read(inherit);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setACL_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setACL_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setACL(channelid, acls, groups, inherit, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setACL_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setACL_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setACL_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(acls);
        __os->write(groups);
        __os->write(inherit);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setACL(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setACL_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__addUserToGroup_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__addUserToGroup_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->addUserToGroup(channelid, session, group, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__addUserToGroup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__addUserToGroup_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__addUserToGroup_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(session);
        __os->write(group);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_addUserToGroup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__addUserToGroup_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__removeUserFromGroup_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__removeUserFromGroup_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->removeUserFromGroup(channelid, session, group, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__removeUserFromGroup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__removeUserFromGroup_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__removeUserFromGroup_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(session);
        __os->write(group);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_removeUserFromGroup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__removeUserFromGroup_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__redirectWhisperGroup_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__redirectWhisperGroup_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->redirectWhisperGroup(session, source, target, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__redirectWhisperGroup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__redirectWhisperGroup_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__redirectWhisperGroup_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(source);
        __os->write(target);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_redirectWhisperGroup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__redirectWhisperGroup_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::NameMap
IceProxy::Murmur::Server::getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getUserNames_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getUserNames_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getUserNames(ids, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getUserNames_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getUserNames_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getUserNames_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(ids);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::NameMap
IceProxy::Murmur::Server::end_getUserNames(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getUserNames_name);
    ::Murmur::NameMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::IdMap
IceProxy::Murmur::Server::getUserIds(const ::Murmur::NameList& names, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getUserIds_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getUserIds_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getUserIds(names, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getUserIds(const ::Murmur::NameList& names, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getUserIds_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getUserIds_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getUserIds_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(names);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::IdMap
IceProxy::Murmur::Server::end_getUserIds(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getUserIds_name);
    ::Murmur::IdMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__registerUser_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__registerUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->registerUser(info, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__registerUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__registerUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__registerUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_registerUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__registerUser_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::unregisterUser(::Ice::Int userid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__unregisterUser_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__unregisterUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->unregisterUser(userid, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_unregisterUser(::Ice::Int userid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__unregisterUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__unregisterUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__unregisterUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_unregisterUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__unregisterUser_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__updateRegistration_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__updateRegistration_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->updateRegistration(userid, info, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__updateRegistration_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__updateRegistration_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__updateRegistration_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_updateRegistration(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__updateRegistration_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::UserInfoMap
IceProxy::Murmur::Server::getRegistration(::Ice::Int userid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getRegistration_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getRegistration_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getRegistration(userid, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getRegistration(::Ice::Int userid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getRegistration_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getRegistration_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getRegistration_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::UserInfoMap
IceProxy::Murmur::Server::end_getRegistration(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getRegistration_name);
    ::Murmur::UserInfoMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::NameMap
IceProxy::Murmur::Server::getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getRegisteredUsers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getRegisteredUsers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getRegisteredUsers(filter, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getRegisteredUsers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getRegisteredUsers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getRegisteredUsers_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(filter);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::NameMap
IceProxy::Murmur::Server::end_getRegisteredUsers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getRegisteredUsers_name);
    ::Murmur::NameMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__verifyPassword_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__verifyPassword_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->verifyPassword(name, pw, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__verifyPassword_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__verifyPassword_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__verifyPassword_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(pw);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_verifyPassword(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__verifyPassword_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::Texture
IceProxy::Murmur::Server::getTexture(::Ice::Int userid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getTexture_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getTexture_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getTexture(userid, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getTexture(::Ice::Int userid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getTexture_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getTexture_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getTexture_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::Texture
IceProxy::Murmur::Server::end_getTexture(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getTexture_name);
    ::Murmur::Texture __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Server::setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__setTexture_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__setTexture_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            __del->setTexture(userid, tex, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__setTexture_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__setTexture_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__setTexture_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __os->write(tex);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Server::end_setTexture(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__setTexture_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidTextureException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Server::getUptime(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Server__getUptime_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Server__getUptime_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Server* __del = dynamic_cast< ::IceDelegate::Murmur::Server*>(__delBase.get());
            return __del->getUptime(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::begin_getUptime(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Server__getUptime_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Server__getUptime_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Server__getUptime_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Server::end_getUptime(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Server__getUptime_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Murmur::Server::ice_staticId()
{
    return ::Murmur::Server::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::Server::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::Server);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::Server::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::Server);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::Server::__newInstance() const
{
    return new Server;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::MetaCallback* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::MetaCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::MetaCallback;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Murmur::MetaCallback::started(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__MetaCallback__started_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::MetaCallback* __del = dynamic_cast< ::IceDelegate::Murmur::MetaCallback*>(__delBase.get());
            __del->started(srv, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::MetaCallback::begin_started(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__MetaCallback__started_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__MetaCallback__started_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(srv);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::MetaCallback::end_started(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__MetaCallback__started_name);
}

void
IceProxy::Murmur::MetaCallback::stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__MetaCallback__stopped_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::MetaCallback* __del = dynamic_cast< ::IceDelegate::Murmur::MetaCallback*>(__delBase.get());
            __del->stopped(srv, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::MetaCallback::begin_stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__MetaCallback__stopped_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__MetaCallback__stopped_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(srv);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::MetaCallback::end_stopped(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Murmur__MetaCallback__stopped_name);
}

const ::std::string&
IceProxy::Murmur::MetaCallback::ice_staticId()
{
    return ::Murmur::MetaCallback::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::MetaCallback::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::MetaCallback);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::MetaCallback::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::MetaCallback);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::MetaCallback::__newInstance() const
{
    return new MetaCallback;
}
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(::IceProxy::Murmur::Meta* p) { return p; }

void
::IceProxy::Murmur::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Murmur::Meta>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Murmur::Meta;
        v->__copyFrom(proxy);
    }
}

::Murmur::ServerPrx
IceProxy::Murmur::Meta::getServer(::Ice::Int id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getServer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getServer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getServer(id, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getServer(::Ice::Int id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getServer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getServer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getServer_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ServerPrx
IceProxy::Murmur::Meta::end_getServer(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getServer_name);
    ::Murmur::ServerPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::ServerPrx
IceProxy::Murmur::Meta::newServer(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__newServer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__newServer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->newServer(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_newServer(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__newServer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__newServer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__newServer_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ServerPrx
IceProxy::Murmur::Meta::end_newServer(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__newServer_name);
    ::Murmur::ServerPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::ServerList
IceProxy::Murmur::Meta::getBootedServers(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getBootedServers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getBootedServers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getBootedServers(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getBootedServers(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getBootedServers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getBootedServers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getBootedServers_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ServerList
IceProxy::Murmur::Meta::end_getBootedServers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getBootedServers_name);
    ::Murmur::ServerList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::ServerList
IceProxy::Murmur::Meta::getAllServers(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getAllServers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getAllServers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getAllServers(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getAllServers(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getAllServers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getAllServers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getAllServers_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ServerList
IceProxy::Murmur::Meta::end_getAllServers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getAllServers_name);
    ::Murmur::ServerList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Murmur::ConfigMap
IceProxy::Murmur::Meta::getDefaultConf(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getDefaultConf_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getDefaultConf_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getDefaultConf(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getDefaultConf(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getDefaultConf_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getDefaultConf_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getDefaultConf_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Murmur::ConfigMap
IceProxy::Murmur::Meta::end_getDefaultConf(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getDefaultConf_name);
    ::Murmur::ConfigMap __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Meta::getVersion(::Ice::Int& major, ::Ice::Int& minor, ::Ice::Int& patch, ::std::string& text, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getVersion_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getVersion_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            __del->getVersion(major, minor, patch, text, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getVersion(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getVersion_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getVersion_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getVersion_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Meta::end_getVersion(::Ice::Int& major, ::Ice::Int& minor, ::Ice::Int& patch, ::std::string& text, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getVersion_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(major);
        __is->read(minor);
        __is->read(patch);
        __is->read(text);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Meta::addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__addCallback_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__addCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            __del->addCallback(cb, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__addCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__addCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__addCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Meta::end_addCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__addCallback_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Murmur::Meta::removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__removeCallback_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__removeCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            __del->removeCallback(cb, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__removeCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__removeCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__removeCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Murmur::Meta::end_removeCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__removeCallback_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::Murmur::Meta::getUptime(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getUptime_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getUptime_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getUptime(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getUptime(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getUptime_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getUptime_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getUptime_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Murmur::Meta::end_getUptime(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getUptime_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::std::string
IceProxy::Murmur::Meta::getSlice(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getSlice_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getSlice_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getSlice(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getSlice(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getSlice_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getSlice_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getSlice_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Murmur::Meta::end_getSlice(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getSlice_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::SliceChecksumDict
IceProxy::Murmur::Meta::getSliceChecksums(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Murmur__Meta__getSliceChecksums_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Murmur__Meta__getSliceChecksums_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Murmur::Meta* __del = dynamic_cast< ::IceDelegate::Murmur::Meta*>(__delBase.get());
            return __del->getSliceChecksums(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::begin_getSliceChecksums(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Murmur__Meta__getSliceChecksums_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Murmur__Meta__getSliceChecksums_name, __del, __cookie);
    try
    {
        __result->__prepare(__Murmur__Meta__getSliceChecksums_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::SliceChecksumDict
IceProxy::Murmur::Meta::end_getSliceChecksums(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Murmur__Meta__getSliceChecksums_name);
    ::Ice::SliceChecksumDict __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Murmur::Meta::ice_staticId()
{
    return ::Murmur::Meta::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Murmur::Meta::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Murmur::Meta);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Murmur::Meta::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Murmur::Meta);
}

::IceProxy::Ice::Object*
IceProxy::Murmur::Meta::__newInstance() const
{
    return new Meta;
}

void
IceDelegateM::Murmur::ServerCallback::userConnected(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__userConnected_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerCallback::userDisconnected(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__userDisconnected_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerCallback::userStateChanged(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__userStateChanged_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerCallback::userTextMessage(const ::Murmur::User& state, const ::Murmur::TextMessage& message, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__userTextMessage_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __os->write(message);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerCallback::channelCreated(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__channelCreated_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerCallback::channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__channelRemoved_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerCallback::channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerCallback__channelStateChanged_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::ServerContextCallback::contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerContextCallback__contextAction_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(action);
        __os->write(usr);
        __os->write(session);
        __os->write(channelid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::Murmur::ServerAuthenticator::authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, ::std::string& newname, ::Murmur::GroupNameList& groups, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerAuthenticator__authenticate_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(pw);
        __os->write(certificates);
        __os->write(certhash);
        __os->write(certstrong);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(newname);
        __is->read(groups);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::Murmur::ServerAuthenticator::getInfo(::Ice::Int id, ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerAuthenticator__getInfo_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(info);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::ServerAuthenticator::nameToId(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerAuthenticator__nameToId_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::Murmur::ServerAuthenticator::idToName(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerAuthenticator__idToName_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::Texture
IceDelegateM::Murmur::ServerAuthenticator::idToTexture(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerAuthenticator__idToTexture_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::Texture __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::ServerUpdatingAuthenticator::registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerUpdatingAuthenticator__registerUser_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::ServerUpdatingAuthenticator::unregisterUser(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerUpdatingAuthenticator__unregisterUser_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::NameMap
IceDelegateM::Murmur::ServerUpdatingAuthenticator::getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(filter);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::NameMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::ServerUpdatingAuthenticator::setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerUpdatingAuthenticator__setInfo_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::ServerUpdatingAuthenticator::setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__ServerUpdatingAuthenticator__setTexture_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __os->write(tex);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::Murmur::Server::isRunning(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__isRunning_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::start(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__start_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerFailureException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::stop(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__stop_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::_cpp_delete(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__delete_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::id(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__id_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__addCallback_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__removeCallback_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setAuthenticator_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(auth);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::Murmur::Server::getConf(const ::std::string& key, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getConf_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(key);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::WriteOnlyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::ConfigMap
IceDelegateM::Murmur::Server::getAllConf(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getAllConf_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::ConfigMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setConf_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(key);
        __os->write(value);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setSuperuserPassword(const ::std::string& pw, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setSuperuserPassword_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(pw);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::LogList
IceDelegateM::Murmur::Server::getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getLog_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(first);
        __os->write(last);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::LogList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::getLogLen(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getLogLen_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::UserMap
IceDelegateM::Murmur::Server::getUsers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getUsers_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::UserMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::ChannelMap
IceDelegateM::Murmur::Server::getChannels(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getChannels_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::ChannelMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::CertificateList
IceDelegateM::Murmur::Server::getCertificateList(::Ice::Int session, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getCertificateList_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::CertificateList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::TreePtr
IceDelegateM::Murmur::Server::getTree(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getTree_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::TreePtr __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::BanList
IceDelegateM::Murmur::Server::getBans(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getBans_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::BanList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setBans(const ::Murmur::BanList& bans, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setBans_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(bans);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__kickUser_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(reason);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::User
IceDelegateM::Murmur::Server::getState(::Ice::Int session, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getState_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::User __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setState(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setState_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__sendMessage_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(text);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::Murmur::Server::hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__hasPermission_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(channelid);
        __os->write(perm);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::effectivePermissions(::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__effectivePermissions_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(channelid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__addContextCallback_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(action);
        __os->write(text);
        __os->write(cb);
        __os->write(ctx);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__removeContextCallback_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::Channel
IceDelegateM::Murmur::Server::getChannelState(::Ice::Int channelid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getChannelState_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::Channel __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setChannelState(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setChannelState_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(state);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::NestingLimitException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::removeChannel(::Ice::Int channelid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__removeChannel_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__addChannel_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(parent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::NestingLimitException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__sendMessageChannel_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(tree);
        __os->write(text);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::getACL(::Ice::Int channelid, ::Murmur::ACLList& acls, ::Murmur::GroupList& groups, bool& inherit, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getACL_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(acls);
        __is->read(groups);
        __is->read(inherit);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setACL_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(acls);
        __os->write(groups);
        __os->write(inherit);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__addUserToGroup_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(session);
        __os->write(group);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__removeUserFromGroup_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(channelid);
        __os->write(session);
        __os->write(group);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidChannelException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__redirectWhisperGroup_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(session);
        __os->write(source);
        __os->write(target);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSessionException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::NameMap
IceDelegateM::Murmur::Server::getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getUserNames_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(ids);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::NameMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::IdMap
IceDelegateM::Murmur::Server::getUserIds(const ::Murmur::NameList& names, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getUserIds_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(names);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::IdMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__registerUser_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::unregisterUser(::Ice::Int userid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__unregisterUser_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__updateRegistration_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::UserInfoMap
IceDelegateM::Murmur::Server::getRegistration(::Ice::Int userid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getRegistration_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::UserInfoMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::NameMap
IceDelegateM::Murmur::Server::getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getRegisteredUsers_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(filter);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::NameMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__verifyPassword_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(pw);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::Texture
IceDelegateM::Murmur::Server::getTexture(::Ice::Int userid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getTexture_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::Texture __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Server::setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__setTexture_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(userid);
        __os->write(tex);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidTextureException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidUserException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Server::getUptime(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Server__getUptime_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Murmur::ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::MetaCallback::started(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__MetaCallback__started_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(srv);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Murmur::MetaCallback::stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__MetaCallback__stopped_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(srv);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Murmur::ServerPrx
IceDelegateM::Murmur::Meta::getServer(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getServer_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Murmur::ServerPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::ServerPrx
IceDelegateM::Murmur::Meta::newServer(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__newServer_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::ServerPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::ServerList
IceDelegateM::Murmur::Meta::getBootedServers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getBootedServers_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::ServerList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::ServerList
IceDelegateM::Murmur::Meta::getAllServers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getAllServers_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::ServerList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Murmur::ConfigMap
IceDelegateM::Murmur::Meta::getDefaultConf(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getDefaultConf_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Murmur::ConfigMap __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Meta::getVersion(::Ice::Int& major, ::Ice::Int& minor, ::Ice::Int& patch, ::std::string& text, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getVersion_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(major);
        __is->read(minor);
        __is->read(patch);
        __is->read(text);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Meta::addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__addCallback_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Murmur::Meta::removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__removeCallback_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(cb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Murmur::InvalidCallbackException&)
            {
                throw;
            }
            catch(const ::Murmur::InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Murmur::Meta::getUptime(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getUptime_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::Murmur::Meta::getSlice(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getSlice_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::SliceChecksumDict
IceDelegateM::Murmur::Meta::getSliceChecksums(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Murmur__Meta__getSliceChecksums_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::SliceChecksumDict __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::userConnected(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::User& __p_state, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userConnected(_m_state, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::User& _m_state;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__userConnected_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::userDisconnected(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::User& __p_state, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userDisconnected(_m_state, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::User& _m_state;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__userDisconnected_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::userStateChanged(const ::Murmur::User& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::User& __p_state, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userStateChanged(_m_state, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::User& _m_state;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__userStateChanged_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::userTextMessage(const ::Murmur::User& state, const ::Murmur::TextMessage& message, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::User& __p_state, const ::Murmur::TextMessage& __p_message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state),
            _m_message(__p_message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userTextMessage(_m_state, _m_message, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::User& _m_state;
        const ::Murmur::TextMessage& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__userTextMessage_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, message, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::channelCreated(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::Channel& __p_state, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->channelCreated(_m_state, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::Channel& _m_state;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__channelCreated_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::Channel& __p_state, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->channelRemoved(_m_state, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::Channel& _m_state;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__channelRemoved_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerCallback::channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::Channel& __p_state, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_state(__p_state)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerCallback* servant = dynamic_cast< ::Murmur::ServerCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->channelStateChanged(_m_state, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::Channel& _m_state;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerCallback__channelStateChanged_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(state, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::ServerContextCallback::contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_action, const ::Murmur::User& __p_usr, ::Ice::Int __p_session, ::Ice::Int __p_channelid, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_action(__p_action),
            _m_usr(__p_usr),
            _m_session(__p_session),
            _m_channelid(__p_channelid)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerContextCallback* servant = dynamic_cast< ::Murmur::ServerContextCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->contextAction(_m_action, _m_usr, _m_session, _m_channelid, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_action;
        const ::Murmur::User& _m_usr;
        ::Ice::Int _m_session;
        ::Ice::Int _m_channelid;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerContextCallback__contextAction_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(action, usr, session, channelid, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::Murmur::ServerAuthenticator::authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, ::std::string& newname, ::Murmur::GroupNameList& groups, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_name, const ::std::string& __p_pw, const ::Murmur::CertificateList& __p_certificates, const ::std::string& __p_certhash, bool __p_certstrong, ::std::string& __p_newname, ::Murmur::GroupNameList& __p_groups, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_name(__p_name),
            _m_pw(__p_pw),
            _m_certificates(__p_certificates),
            _m_certhash(__p_certhash),
            _m_certstrong(__p_certstrong),
            _m_newname(__p_newname),
            _m_groups(__p_groups)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerAuthenticator* servant = dynamic_cast< ::Murmur::ServerAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->authenticate(_m_name, _m_pw, _m_certificates, _m_certhash, _m_certstrong, _m_newname, _m_groups, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_name;
        const ::std::string& _m_pw;
        const ::Murmur::CertificateList& _m_certificates;
        const ::std::string& _m_certhash;
        bool _m_certstrong;
        ::std::string& _m_newname;
        ::Murmur::GroupNameList& _m_groups;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerAuthenticator__authenticate_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, name, pw, certificates, certhash, certstrong, newname, groups, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::Murmur::ServerAuthenticator::getInfo(::Ice::Int id, ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int __p_id, ::Murmur::UserInfoMap& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_id(__p_id),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerAuthenticator* servant = dynamic_cast< ::Murmur::ServerAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getInfo(_m_id, _m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_id;
        ::Murmur::UserInfoMap& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerAuthenticator__getInfo_name, ::Ice::Idempotent, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, id, info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Murmur::ServerAuthenticator::nameToId(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerAuthenticator* servant = dynamic_cast< ::Murmur::ServerAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->nameToId(_m_name, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerAuthenticator__nameToId_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::Murmur::ServerAuthenticator::idToName(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, ::Ice::Int __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerAuthenticator* servant = dynamic_cast< ::Murmur::ServerAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->idToName(_m_id, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
        ::Ice::Int _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerAuthenticator__idToName_name, ::Ice::Idempotent, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Murmur::Texture
IceDelegateD::Murmur::ServerAuthenticator::idToTexture(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Murmur::Texture& __result, ::Ice::Int __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerAuthenticator* servant = dynamic_cast< ::Murmur::ServerAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->idToTexture(_m_id, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Murmur::Texture& _result;
        ::Ice::Int _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerAuthenticator__idToTexture_name, ::Ice::Idempotent, __context);
    ::Murmur::Texture __result;
    try
    {
        _DirectI __direct(__result, id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Murmur::ServerUpdatingAuthenticator::registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Murmur::UserInfoMap& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerUpdatingAuthenticator* servant = dynamic_cast< ::Murmur::ServerUpdatingAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->registerUser(_m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::Murmur::UserInfoMap& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerUpdatingAuthenticator__registerUser_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Murmur::ServerUpdatingAuthenticator::unregisterUser(::Ice::Int id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerUpdatingAuthenticator* servant = dynamic_cast< ::Murmur::ServerUpdatingAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->unregisterUser(_m_id, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerUpdatingAuthenticator__unregisterUser_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Murmur::NameMap
IceDelegateD::Murmur::ServerUpdatingAuthenticator::getRegisteredUsers(const ::std::string& filter, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Murmur::NameMap& __result, const ::std::string& __p_filter, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_filter(__p_filter)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerUpdatingAuthenticator* servant = dynamic_cast< ::Murmur::ServerUpdatingAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getRegisteredUsers(_m_filter, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Murmur::NameMap& _result;
        const ::std::string& _m_filter;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerUpdatingAuthenticator__getRegisteredUsers_name, ::Ice::Idempotent, __context);
    ::Murmur::NameMap __result;
    try
    {
        _DirectI __direct(__result, filter, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Murmur::ServerUpdatingAuthenticator::setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_id, const ::Murmur::UserInfoMap& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_id(__p_id),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerUpdatingAuthenticator* servant = dynamic_cast< ::Murmur::ServerUpdatingAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->setInfo(_m_id, _m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_id;
        const ::Murmur::UserInfoMap& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerUpdatingAuthenticator__setInfo_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, id, info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Murmur::ServerUpdatingAuthenticator::setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_id, const ::Murmur::Texture& __p_tex, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_id(__p_id),
            _m_tex(__p_tex)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::ServerUpdatingAuthenticator* servant = dynamic_cast< ::Murmur::ServerUpdatingAuthenticator*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->setTexture(_m_id, _m_tex, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_id;
        const ::Murmur::Texture& _m_tex;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__ServerUpdatingAuthenticator__setTexture_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, id, tex, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::Murmur::Server::isRunning(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return bool(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::start(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::stop(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::_cpp_delete(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Int
IceDelegateD::Murmur::Server::id(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::addCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::removeCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::setAuthenticator(const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::std::string
IceDelegateD::Murmur::Server::getConf(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::std::string(); // to avoid a warning with some compilers;
}

::Murmur::ConfigMap
IceDelegateD::Murmur::Server::getAllConf(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ConfigMap(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::setConf(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::setSuperuserPassword(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Murmur::LogList
IceDelegateD::Murmur::Server::getLog(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::LogList(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::Murmur::Server::getLogLen(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Murmur::UserMap
IceDelegateD::Murmur::Server::getUsers(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::UserMap(); // to avoid a warning with some compilers;
}

::Murmur::ChannelMap
IceDelegateD::Murmur::Server::getChannels(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ChannelMap(); // to avoid a warning with some compilers;
}

::Murmur::CertificateList
IceDelegateD::Murmur::Server::getCertificateList(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::CertificateList(); // to avoid a warning with some compilers;
}

::Murmur::TreePtr
IceDelegateD::Murmur::Server::getTree(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::TreePtr(); // to avoid a warning with some compilers;
}

::Murmur::BanList
IceDelegateD::Murmur::Server::getBans(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::BanList(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::setBans(const ::Murmur::BanList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::kickUser(::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Murmur::User
IceDelegateD::Murmur::Server::getState(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::User(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::setState(const ::Murmur::User&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::sendMessage(::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

bool
IceDelegateD::Murmur::Server::hasPermission(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return bool(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::Murmur::Server::effectivePermissions(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::addContextCallback(::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::removeContextCallback(const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Murmur::Channel
IceDelegateD::Murmur::Server::getChannelState(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::Channel(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::setChannelState(const ::Murmur::Channel&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::removeChannel(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Int
IceDelegateD::Murmur::Server::addChannel(const ::std::string&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::sendMessageChannel(::Ice::Int, bool, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::getACL(::Ice::Int, ::Murmur::ACLList&, ::Murmur::GroupList&, bool&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::setACL(::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::addUserToGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::removeUserFromGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::redirectWhisperGroup(::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Murmur::NameMap
IceDelegateD::Murmur::Server::getUserNames(const ::Murmur::IdList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::NameMap(); // to avoid a warning with some compilers;
}

::Murmur::IdMap
IceDelegateD::Murmur::Server::getUserIds(const ::Murmur::NameList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::IdMap(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::Murmur::Server::registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::unregisterUser(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Server::updateRegistration(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Murmur::UserInfoMap
IceDelegateD::Murmur::Server::getRegistration(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::UserInfoMap(); // to avoid a warning with some compilers;
}

::Murmur::NameMap
IceDelegateD::Murmur::Server::getRegisteredUsers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::NameMap(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::Murmur::Server::verifyPassword(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Murmur::Texture
IceDelegateD::Murmur::Server::getTexture(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::Texture(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Server::setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Int
IceDelegateD::Murmur::Server::getUptime(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::MetaCallback::started(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::ServerPrx& __p_srv, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_srv(__p_srv)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::MetaCallback* servant = dynamic_cast< ::Murmur::MetaCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->started(_m_srv, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::ServerPrx& _m_srv;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__MetaCallback__started_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(srv, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Murmur::MetaCallback::stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Murmur::ServerPrx& __p_srv, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_srv(__p_srv)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Murmur::MetaCallback* servant = dynamic_cast< ::Murmur::MetaCallback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->stopped(_m_srv, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Murmur::ServerPrx& _m_srv;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Murmur__MetaCallback__stopped_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(srv, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Murmur::ServerPrx
IceDelegateD::Murmur::Meta::getServer(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ServerPrx(); // to avoid a warning with some compilers;
}

::Murmur::ServerPrx
IceDelegateD::Murmur::Meta::newServer(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ServerPrx(); // to avoid a warning with some compilers;
}

::Murmur::ServerList
IceDelegateD::Murmur::Meta::getBootedServers(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ServerList(); // to avoid a warning with some compilers;
}

::Murmur::ServerList
IceDelegateD::Murmur::Meta::getAllServers(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ServerList(); // to avoid a warning with some compilers;
}

::Murmur::ConfigMap
IceDelegateD::Murmur::Meta::getDefaultConf(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Murmur::ConfigMap(); // to avoid a warning with some compilers;
}

void
IceDelegateD::Murmur::Meta::getVersion(::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Meta::addCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::Murmur::Meta::removeCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::Int
IceDelegateD::Murmur::Meta::getUptime(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::std::string
IceDelegateD::Murmur::Meta::getSlice(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::std::string(); // to avoid a warning with some compilers;
}

::Ice::SliceChecksumDict
IceDelegateD::Murmur::Meta::getSliceChecksums(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::SliceChecksumDict(); // to avoid a warning with some compilers;
}

::Ice::Object* Murmur::upCast(::Murmur::Tree* p) { return p; }
::Ice::ObjectPtr
Murmur::Tree::ice_clone() const
{
    ::Ice::Object* __p = new Tree(*this);
    return __p;
}

namespace
{
const ::std::string __Murmur__Tree_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Tree"
};

}

bool
Murmur::Tree::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__Tree_ids, __Murmur__Tree_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::Tree::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__Tree_ids[0], &__Murmur__Tree_ids[2]);
}

const ::std::string&
Murmur::Tree::ice_id(const ::Ice::Current&) const
{
    return __Murmur__Tree_ids[1];
}

const ::std::string&
Murmur::Tree::ice_staticId()
{
    return __Murmur__Tree_ids[1];
}

void
Murmur::Tree::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
Murmur::Tree::__usesGC()
{
    return true;
}

void
Murmur::Tree::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::Murmur::TreeList::const_iterator _i0 = children.begin(); _i0 != children.end(); ++_i0)
        {
            if((*_i0))
            {
                ::Murmur::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
Murmur::Tree::__gcClear()
{
    {
        for(::Murmur::TreeList::iterator _i0 = children.begin(); _i0 != children.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::Murmur::upCast((*_i0).get())->__usesGC())
                {
                    ::Murmur::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
Murmur::Tree::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(c);
    __os->write(children);
    __os->write(users);
    __os->endWriteSlice();
}

void
Murmur::Tree::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(c);
    __is->read(children);
    __is->read(users);
    __is->endReadSlice();
}

namespace
{

class __F__Murmur__Tree : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::Murmur::Tree::ice_staticId());
        return new ::Murmur::Tree;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__Murmur__Tree_Ptr = new __F__Murmur__Tree;

class __F__Murmur__Tree__Init
{
public:

    __F__Murmur__Tree__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Murmur::Tree::ice_staticId(), __F__Murmur__Tree_Ptr);
    }

    ~__F__Murmur__Tree__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Murmur::Tree::ice_staticId());
    }
};

const __F__Murmur__Tree__Init __F__Murmur__Tree__i;

}

const ::Ice::ObjectFactoryPtr&
Murmur::Tree::ice_factory()
{
    return __F__Murmur__Tree_Ptr;
}

void 
Murmur::__patch(TreePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::TreePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::Tree::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::ServerCallback* p) { return p; }

namespace
{
const ::std::string __Murmur__ServerCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerCallback"
};

}

bool
Murmur::ServerCallback::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__ServerCallback_ids, __Murmur__ServerCallback_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::ServerCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__ServerCallback_ids[0], &__Murmur__ServerCallback_ids[2]);
}

const ::std::string&
Murmur::ServerCallback::ice_id(const ::Ice::Current&) const
{
    return __Murmur__ServerCallback_ids[1];
}

const ::std::string&
Murmur::ServerCallback::ice_staticId()
{
    return __Murmur__ServerCallback_ids[1];
}

::Ice::DispatchStatus
Murmur::ServerCallback::___userConnected(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::User state;
    __is->read(state);
    __inS.endReadParams();
    userConnected(state, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerCallback::___userDisconnected(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::User state;
    __is->read(state);
    __inS.endReadParams();
    userDisconnected(state, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerCallback::___userStateChanged(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::User state;
    __is->read(state);
    __inS.endReadParams();
    userStateChanged(state, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerCallback::___userTextMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::User state;
    ::Murmur::TextMessage message;
    __is->read(state);
    __is->read(message);
    __inS.endReadParams();
    userTextMessage(state, message, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerCallback::___channelCreated(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::Channel state;
    __is->read(state);
    __inS.endReadParams();
    channelCreated(state, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerCallback::___channelRemoved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::Channel state;
    __is->read(state);
    __inS.endReadParams();
    channelRemoved(state, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerCallback::___channelStateChanged(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::Channel state;
    __is->read(state);
    __inS.endReadParams();
    channelStateChanged(state, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Murmur__ServerCallback_all[] =
{
    "channelCreated",
    "channelRemoved",
    "channelStateChanged",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "userConnected",
    "userDisconnected",
    "userStateChanged",
    "userTextMessage"
};

}

::Ice::DispatchStatus
Murmur::ServerCallback::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__ServerCallback_all, __Murmur__ServerCallback_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__ServerCallback_all)
    {
        case 0:
        {
            return ___channelCreated(in, current);
        }
        case 1:
        {
            return ___channelRemoved(in, current);
        }
        case 2:
        {
            return ___channelStateChanged(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___userConnected(in, current);
        }
        case 8:
        {
            return ___userDisconnected(in, current);
        }
        case 9:
        {
            return ___userStateChanged(in, current);
        }
        case 10:
        {
            return ___userTextMessage(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::ServerCallback::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::ServerCallback::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(ServerCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::ServerCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::ServerCallback::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::ServerContextCallback* p) { return p; }

namespace
{
const ::std::string __Murmur__ServerContextCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerContextCallback"
};

}

bool
Murmur::ServerContextCallback::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__ServerContextCallback_ids, __Murmur__ServerContextCallback_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::ServerContextCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__ServerContextCallback_ids[0], &__Murmur__ServerContextCallback_ids[2]);
}

const ::std::string&
Murmur::ServerContextCallback::ice_id(const ::Ice::Current&) const
{
    return __Murmur__ServerContextCallback_ids[1];
}

const ::std::string&
Murmur::ServerContextCallback::ice_staticId()
{
    return __Murmur__ServerContextCallback_ids[1];
}

::Ice::DispatchStatus
Murmur::ServerContextCallback::___contextAction(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string action;
    ::Murmur::User usr;
    ::Ice::Int session;
    ::Ice::Int channelid;
    __is->read(action);
    __is->read(usr);
    __is->read(session);
    __is->read(channelid);
    __inS.endReadParams();
    contextAction(action, usr, session, channelid, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Murmur__ServerContextCallback_all[] =
{
    "contextAction",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Murmur::ServerContextCallback::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__ServerContextCallback_all, __Murmur__ServerContextCallback_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__ServerContextCallback_all)
    {
        case 0:
        {
            return ___contextAction(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::ServerContextCallback::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::ServerContextCallback::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(ServerContextCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::ServerContextCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::ServerContextCallback::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::ServerAuthenticator* p) { return p; }

namespace
{
const ::std::string __Murmur__ServerAuthenticator_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerAuthenticator"
};

}

bool
Murmur::ServerAuthenticator::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__ServerAuthenticator_ids, __Murmur__ServerAuthenticator_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::ServerAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__ServerAuthenticator_ids[0], &__Murmur__ServerAuthenticator_ids[2]);
}

const ::std::string&
Murmur::ServerAuthenticator::ice_id(const ::Ice::Current&) const
{
    return __Murmur__ServerAuthenticator_ids[1];
}

const ::std::string&
Murmur::ServerAuthenticator::ice_staticId()
{
    return __Murmur__ServerAuthenticator_ids[1];
}

::Ice::DispatchStatus
Murmur::ServerAuthenticator::___authenticate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    ::std::string pw;
    ::Murmur::CertificateList certificates;
    ::std::string certhash;
    bool certstrong;
    __is->read(name);
    __is->read(pw);
    __is->read(certificates);
    __is->read(certhash);
    __is->read(certstrong);
    __inS.endReadParams();
    ::std::string newname;
    ::Murmur::GroupNameList groups;
    ::Ice::Int __ret = authenticate(name, pw, certificates, certhash, certstrong, newname, groups, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(newname);
    __os->write(groups);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerAuthenticator::___getInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    __is->read(id);
    __inS.endReadParams();
    ::Murmur::UserInfoMap info;
    bool __ret = getInfo(id, info, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(info);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerAuthenticator::___nameToId(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    ::Ice::Int __ret = nameToId(name, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerAuthenticator::___idToName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    __is->read(id);
    __inS.endReadParams();
    ::std::string __ret = idToName(id, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerAuthenticator::___idToTexture(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    __is->read(id);
    __inS.endReadParams();
    ::Murmur::Texture __ret = idToTexture(id, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Murmur__ServerAuthenticator_all[] =
{
    "authenticate",
    "getInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId"
};

}

::Ice::DispatchStatus
Murmur::ServerAuthenticator::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__ServerAuthenticator_all, __Murmur__ServerAuthenticator_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__ServerAuthenticator_all)
    {
        case 0:
        {
            return ___authenticate(in, current);
        }
        case 1:
        {
            return ___getInfo(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
        case 6:
        {
            return ___idToName(in, current);
        }
        case 7:
        {
            return ___idToTexture(in, current);
        }
        case 8:
        {
            return ___nameToId(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::ServerAuthenticator::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::ServerAuthenticator::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(ServerAuthenticatorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::ServerAuthenticatorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::ServerAuthenticator::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::ServerUpdatingAuthenticator* p) { return p; }

namespace
{
const ::std::string __Murmur__ServerUpdatingAuthenticator_ids[3] =
{
    "::Ice::Object",
    "::Murmur::ServerAuthenticator",
    "::Murmur::ServerUpdatingAuthenticator"
};

}

bool
Murmur::ServerUpdatingAuthenticator::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__ServerUpdatingAuthenticator_ids, __Murmur__ServerUpdatingAuthenticator_ids + 3, _s);
}

::std::vector< ::std::string>
Murmur::ServerUpdatingAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__ServerUpdatingAuthenticator_ids[0], &__Murmur__ServerUpdatingAuthenticator_ids[3]);
}

const ::std::string&
Murmur::ServerUpdatingAuthenticator::ice_id(const ::Ice::Current&) const
{
    return __Murmur__ServerUpdatingAuthenticator_ids[2];
}

const ::std::string&
Murmur::ServerUpdatingAuthenticator::ice_staticId()
{
    return __Murmur__ServerUpdatingAuthenticator_ids[2];
}

::Ice::DispatchStatus
Murmur::ServerUpdatingAuthenticator::___registerUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::UserInfoMap info;
    __is->read(info);
    __inS.endReadParams();
    ::Ice::Int __ret = registerUser(info, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerUpdatingAuthenticator::___unregisterUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    __is->read(id);
    __inS.endReadParams();
    ::Ice::Int __ret = unregisterUser(id, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerUpdatingAuthenticator::___getRegisteredUsers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string filter;
    __is->read(filter);
    __inS.endReadParams();
    ::Murmur::NameMap __ret = getRegisteredUsers(filter, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerUpdatingAuthenticator::___setInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    ::Murmur::UserInfoMap info;
    __is->read(id);
    __is->read(info);
    __inS.endReadParams();
    ::Ice::Int __ret = setInfo(id, info, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::ServerUpdatingAuthenticator::___setTexture(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    ::Murmur::Texture tex;
    __is->read(id);
    __is->read(tex);
    __inS.endReadParams();
    ::Ice::Int __ret = setTexture(id, tex, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Murmur__ServerUpdatingAuthenticator_all[] =
{
    "authenticate",
    "getInfo",
    "getRegisteredUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId",
    "registerUser",
    "setInfo",
    "setTexture",
    "unregisterUser"
};

}

::Ice::DispatchStatus
Murmur::ServerUpdatingAuthenticator::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__ServerUpdatingAuthenticator_all, __Murmur__ServerUpdatingAuthenticator_all + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__ServerUpdatingAuthenticator_all)
    {
        case 0:
        {
            return ___authenticate(in, current);
        }
        case 1:
        {
            return ___getInfo(in, current);
        }
        case 2:
        {
            return ___getRegisteredUsers(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___idToName(in, current);
        }
        case 8:
        {
            return ___idToTexture(in, current);
        }
        case 9:
        {
            return ___nameToId(in, current);
        }
        case 10:
        {
            return ___registerUser(in, current);
        }
        case 11:
        {
            return ___setInfo(in, current);
        }
        case 12:
        {
            return ___setTexture(in, current);
        }
        case 13:
        {
            return ___unregisterUser(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::ServerUpdatingAuthenticator::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::ServerUpdatingAuthenticator::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(ServerUpdatingAuthenticatorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::ServerUpdatingAuthenticatorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::ServerUpdatingAuthenticator::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::Server* p) { return p; }

namespace
{
const ::std::string __Murmur__Server_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Server"
};

}

bool
Murmur::Server::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__Server_ids, __Murmur__Server_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__Server_ids[0], &__Murmur__Server_ids[2]);
}

const ::std::string&
Murmur::Server::ice_id(const ::Ice::Current&) const
{
    return __Murmur__Server_ids[1];
}

const ::std::string&
Murmur::Server::ice_staticId()
{
    return __Murmur__Server_ids[1];
}

::Ice::DispatchStatus
Murmur::Server::___isRunning(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_isRunningPtr __cb = new IceAsync::Murmur::AMD_Server_isRunning(__inS);
    try
    {
        isRunning_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___start(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_startPtr __cb = new IceAsync::Murmur::AMD_Server_start(__inS);
    try
    {
        start_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___stop(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_stopPtr __cb = new IceAsync::Murmur::AMD_Server_stop(__inS);
    try
    {
        stop_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___delete(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_deletePtr __cb = new IceAsync::Murmur::AMD_Server_delete(__inS);
    try
    {
        delete_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___id(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_idPtr __cb = new IceAsync::Murmur::AMD_Server_id(__inS);
    try
    {
        id_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___addCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::ServerCallbackPrx cb;
    __is->read(cb);
    __inS.endReadParams();
    ::Murmur::AMD_Server_addCallbackPtr __cb = new IceAsync::Murmur::AMD_Server_addCallback(__inS);
    try
    {
        addCallback_async(__cb, cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___removeCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::ServerCallbackPrx cb;
    __is->read(cb);
    __inS.endReadParams();
    ::Murmur::AMD_Server_removeCallbackPtr __cb = new IceAsync::Murmur::AMD_Server_removeCallback(__inS);
    try
    {
        removeCallback_async(__cb, cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setAuthenticator(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::ServerAuthenticatorPrx auth;
    __is->read(auth);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setAuthenticatorPtr __cb = new IceAsync::Murmur::AMD_Server_setAuthenticator(__inS);
    try
    {
        setAuthenticator_async(__cb, auth, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getConf(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string key;
    __is->read(key);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getConfPtr __cb = new IceAsync::Murmur::AMD_Server_getConf(__inS);
    try
    {
        getConf_async(__cb, key, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getAllConf(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getAllConfPtr __cb = new IceAsync::Murmur::AMD_Server_getAllConf(__inS);
    try
    {
        getAllConf_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setConf(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string key;
    ::std::string value;
    __is->read(key);
    __is->read(value);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setConfPtr __cb = new IceAsync::Murmur::AMD_Server_setConf(__inS);
    try
    {
        setConf_async(__cb, key, value, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setSuperuserPassword(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string pw;
    __is->read(pw);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setSuperuserPasswordPtr __cb = new IceAsync::Murmur::AMD_Server_setSuperuserPassword(__inS);
    try
    {
        setSuperuserPassword_async(__cb, pw, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getLog(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int first;
    ::Ice::Int last;
    __is->read(first);
    __is->read(last);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getLogPtr __cb = new IceAsync::Murmur::AMD_Server_getLog(__inS);
    try
    {
        getLog_async(__cb, first, last, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getLogLen(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getLogLenPtr __cb = new IceAsync::Murmur::AMD_Server_getLogLen(__inS);
    try
    {
        getLogLen_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getUsers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getUsersPtr __cb = new IceAsync::Murmur::AMD_Server_getUsers(__inS);
    try
    {
        getUsers_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getChannels(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getChannelsPtr __cb = new IceAsync::Murmur::AMD_Server_getChannels(__inS);
    try
    {
        getChannels_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getCertificateList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    __is->read(session);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getCertificateListPtr __cb = new IceAsync::Murmur::AMD_Server_getCertificateList(__inS);
    try
    {
        getCertificateList_async(__cb, session, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getTree(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getTreePtr __cb = new IceAsync::Murmur::AMD_Server_getTree(__inS);
    try
    {
        getTree_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getBans(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getBansPtr __cb = new IceAsync::Murmur::AMD_Server_getBans(__inS);
    try
    {
        getBans_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setBans(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::BanList bans;
    __is->read(bans);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setBansPtr __cb = new IceAsync::Murmur::AMD_Server_setBans(__inS);
    try
    {
        setBans_async(__cb, bans, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___kickUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    ::std::string reason;
    __is->read(session);
    __is->read(reason);
    __inS.endReadParams();
    ::Murmur::AMD_Server_kickUserPtr __cb = new IceAsync::Murmur::AMD_Server_kickUser(__inS);
    try
    {
        kickUser_async(__cb, session, reason, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    __is->read(session);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getStatePtr __cb = new IceAsync::Murmur::AMD_Server_getState(__inS);
    try
    {
        getState_async(__cb, session, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::User state;
    __is->read(state);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setStatePtr __cb = new IceAsync::Murmur::AMD_Server_setState(__inS);
    try
    {
        setState_async(__cb, state, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___sendMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    ::std::string text;
    __is->read(session);
    __is->read(text);
    __inS.endReadParams();
    ::Murmur::AMD_Server_sendMessagePtr __cb = new IceAsync::Murmur::AMD_Server_sendMessage(__inS);
    try
    {
        sendMessage_async(__cb, session, text, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___hasPermission(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    ::Ice::Int channelid;
    ::Ice::Int perm;
    __is->read(session);
    __is->read(channelid);
    __is->read(perm);
    __inS.endReadParams();
    ::Murmur::AMD_Server_hasPermissionPtr __cb = new IceAsync::Murmur::AMD_Server_hasPermission(__inS);
    try
    {
        hasPermission_async(__cb, session, channelid, perm, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___effectivePermissions(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    ::Ice::Int channelid;
    __is->read(session);
    __is->read(channelid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_effectivePermissionsPtr __cb = new IceAsync::Murmur::AMD_Server_effectivePermissions(__inS);
    try
    {
        effectivePermissions_async(__cb, session, channelid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___addContextCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    ::std::string action;
    ::std::string text;
    ::Murmur::ServerContextCallbackPrx cb;
    ::Ice::Int ctx;
    __is->read(session);
    __is->read(action);
    __is->read(text);
    __is->read(cb);
    __is->read(ctx);
    __inS.endReadParams();
    ::Murmur::AMD_Server_addContextCallbackPtr __cb = new IceAsync::Murmur::AMD_Server_addContextCallback(__inS);
    try
    {
        addContextCallback_async(__cb, session, action, text, cb, ctx, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___removeContextCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::ServerContextCallbackPrx cb;
    __is->read(cb);
    __inS.endReadParams();
    ::Murmur::AMD_Server_removeContextCallbackPtr __cb = new IceAsync::Murmur::AMD_Server_removeContextCallback(__inS);
    try
    {
        removeContextCallback_async(__cb, cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getChannelState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    __is->read(channelid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getChannelStatePtr __cb = new IceAsync::Murmur::AMD_Server_getChannelState(__inS);
    try
    {
        getChannelState_async(__cb, channelid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setChannelState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::Channel state;
    __is->read(state);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setChannelStatePtr __cb = new IceAsync::Murmur::AMD_Server_setChannelState(__inS);
    try
    {
        setChannelState_async(__cb, state, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___removeChannel(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    __is->read(channelid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_removeChannelPtr __cb = new IceAsync::Murmur::AMD_Server_removeChannel(__inS);
    try
    {
        removeChannel_async(__cb, channelid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___addChannel(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    ::Ice::Int parent;
    __is->read(name);
    __is->read(parent);
    __inS.endReadParams();
    ::Murmur::AMD_Server_addChannelPtr __cb = new IceAsync::Murmur::AMD_Server_addChannel(__inS);
    try
    {
        addChannel_async(__cb, name, parent, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___sendMessageChannel(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    bool tree;
    ::std::string text;
    __is->read(channelid);
    __is->read(tree);
    __is->read(text);
    __inS.endReadParams();
    ::Murmur::AMD_Server_sendMessageChannelPtr __cb = new IceAsync::Murmur::AMD_Server_sendMessageChannel(__inS);
    try
    {
        sendMessageChannel_async(__cb, channelid, tree, text, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getACL(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    __is->read(channelid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getACLPtr __cb = new IceAsync::Murmur::AMD_Server_getACL(__inS);
    try
    {
        getACL_async(__cb, channelid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setACL(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    ::Murmur::ACLList acls;
    ::Murmur::GroupList groups;
    bool inherit;
    __is->read(channelid);
    __is->read(acls);
    __is->read(groups);
    __is->read(inherit);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setACLPtr __cb = new IceAsync::Murmur::AMD_Server_setACL(__inS);
    try
    {
        setACL_async(__cb, channelid, acls, groups, inherit, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___addUserToGroup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    ::Ice::Int session;
    ::std::string group;
    __is->read(channelid);
    __is->read(session);
    __is->read(group);
    __inS.endReadParams();
    ::Murmur::AMD_Server_addUserToGroupPtr __cb = new IceAsync::Murmur::AMD_Server_addUserToGroup(__inS);
    try
    {
        addUserToGroup_async(__cb, channelid, session, group, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___removeUserFromGroup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int channelid;
    ::Ice::Int session;
    ::std::string group;
    __is->read(channelid);
    __is->read(session);
    __is->read(group);
    __inS.endReadParams();
    ::Murmur::AMD_Server_removeUserFromGroupPtr __cb = new IceAsync::Murmur::AMD_Server_removeUserFromGroup(__inS);
    try
    {
        removeUserFromGroup_async(__cb, channelid, session, group, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___redirectWhisperGroup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int session;
    ::std::string source;
    ::std::string target;
    __is->read(session);
    __is->read(source);
    __is->read(target);
    __inS.endReadParams();
    ::Murmur::AMD_Server_redirectWhisperGroupPtr __cb = new IceAsync::Murmur::AMD_Server_redirectWhisperGroup(__inS);
    try
    {
        redirectWhisperGroup_async(__cb, session, source, target, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getUserNames(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::IdList ids;
    __is->read(ids);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getUserNamesPtr __cb = new IceAsync::Murmur::AMD_Server_getUserNames(__inS);
    try
    {
        getUserNames_async(__cb, ids, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getUserIds(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::NameList names;
    __is->read(names);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getUserIdsPtr __cb = new IceAsync::Murmur::AMD_Server_getUserIds(__inS);
    try
    {
        getUserIds_async(__cb, names, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___registerUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::UserInfoMap info;
    __is->read(info);
    __inS.endReadParams();
    ::Murmur::AMD_Server_registerUserPtr __cb = new IceAsync::Murmur::AMD_Server_registerUser(__inS);
    try
    {
        registerUser_async(__cb, info, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___unregisterUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int userid;
    __is->read(userid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_unregisterUserPtr __cb = new IceAsync::Murmur::AMD_Server_unregisterUser(__inS);
    try
    {
        unregisterUser_async(__cb, userid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___updateRegistration(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int userid;
    ::Murmur::UserInfoMap info;
    __is->read(userid);
    __is->read(info);
    __inS.endReadParams();
    ::Murmur::AMD_Server_updateRegistrationPtr __cb = new IceAsync::Murmur::AMD_Server_updateRegistration(__inS);
    try
    {
        updateRegistration_async(__cb, userid, info, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getRegistration(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int userid;
    __is->read(userid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getRegistrationPtr __cb = new IceAsync::Murmur::AMD_Server_getRegistration(__inS);
    try
    {
        getRegistration_async(__cb, userid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getRegisteredUsers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string filter;
    __is->read(filter);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getRegisteredUsersPtr __cb = new IceAsync::Murmur::AMD_Server_getRegisteredUsers(__inS);
    try
    {
        getRegisteredUsers_async(__cb, filter, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___verifyPassword(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    ::std::string pw;
    __is->read(name);
    __is->read(pw);
    __inS.endReadParams();
    ::Murmur::AMD_Server_verifyPasswordPtr __cb = new IceAsync::Murmur::AMD_Server_verifyPassword(__inS);
    try
    {
        verifyPassword_async(__cb, name, pw, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getTexture(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int userid;
    __is->read(userid);
    __inS.endReadParams();
    ::Murmur::AMD_Server_getTexturePtr __cb = new IceAsync::Murmur::AMD_Server_getTexture(__inS);
    try
    {
        getTexture_async(__cb, userid, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___setTexture(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int userid;
    ::Murmur::Texture tex;
    __is->read(userid);
    __is->read(tex);
    __inS.endReadParams();
    ::Murmur::AMD_Server_setTexturePtr __cb = new IceAsync::Murmur::AMD_Server_setTexture(__inS);
    try
    {
        setTexture_async(__cb, userid, tex, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Server::___getUptime(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Server_getUptimePtr __cb = new IceAsync::Murmur::AMD_Server_getUptime(__inS);
    try
    {
        getUptime_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Murmur__Server_all[] =
{
    "addCallback",
    "addChannel",
    "addContextCallback",
    "addUserToGroup",
    "delete",
    "effectivePermissions",
    "getACL",
    "getAllConf",
    "getBans",
    "getCertificateList",
    "getChannelState",
    "getChannels",
    "getConf",
    "getLog",
    "getLogLen",
    "getRegisteredUsers",
    "getRegistration",
    "getState",
    "getTexture",
    "getTree",
    "getUptime",
    "getUserIds",
    "getUserNames",
    "getUsers",
    "hasPermission",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "id",
    "isRunning",
    "kickUser",
    "redirectWhisperGroup",
    "registerUser",
    "removeCallback",
    "removeChannel",
    "removeContextCallback",
    "removeUserFromGroup",
    "sendMessage",
    "sendMessageChannel",
    "setACL",
    "setAuthenticator",
    "setBans",
    "setChannelState",
    "setConf",
    "setState",
    "setSuperuserPassword",
    "setTexture",
    "start",
    "stop",
    "unregisterUser",
    "updateRegistration",
    "verifyPassword"
};

}

::Ice::DispatchStatus
Murmur::Server::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__Server_all, __Murmur__Server_all + 53, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__Server_all)
    {
        case 0:
        {
            return ___addCallback(in, current);
        }
        case 1:
        {
            return ___addChannel(in, current);
        }
        case 2:
        {
            return ___addContextCallback(in, current);
        }
        case 3:
        {
            return ___addUserToGroup(in, current);
        }
        case 4:
        {
            return ___delete(in, current);
        }
        case 5:
        {
            return ___effectivePermissions(in, current);
        }
        case 6:
        {
            return ___getACL(in, current);
        }
        case 7:
        {
            return ___getAllConf(in, current);
        }
        case 8:
        {
            return ___getBans(in, current);
        }
        case 9:
        {
            return ___getCertificateList(in, current);
        }
        case 10:
        {
            return ___getChannelState(in, current);
        }
        case 11:
        {
            return ___getChannels(in, current);
        }
        case 12:
        {
            return ___getConf(in, current);
        }
        case 13:
        {
            return ___getLog(in, current);
        }
        case 14:
        {
            return ___getLogLen(in, current);
        }
        case 15:
        {
            return ___getRegisteredUsers(in, current);
        }
        case 16:
        {
            return ___getRegistration(in, current);
        }
        case 17:
        {
            return ___getState(in, current);
        }
        case 18:
        {
            return ___getTexture(in, current);
        }
        case 19:
        {
            return ___getTree(in, current);
        }
        case 20:
        {
            return ___getUptime(in, current);
        }
        case 21:
        {
            return ___getUserIds(in, current);
        }
        case 22:
        {
            return ___getUserNames(in, current);
        }
        case 23:
        {
            return ___getUsers(in, current);
        }
        case 24:
        {
            return ___hasPermission(in, current);
        }
        case 25:
        {
            return ___ice_id(in, current);
        }
        case 26:
        {
            return ___ice_ids(in, current);
        }
        case 27:
        {
            return ___ice_isA(in, current);
        }
        case 28:
        {
            return ___ice_ping(in, current);
        }
        case 29:
        {
            return ___id(in, current);
        }
        case 30:
        {
            return ___isRunning(in, current);
        }
        case 31:
        {
            return ___kickUser(in, current);
        }
        case 32:
        {
            return ___redirectWhisperGroup(in, current);
        }
        case 33:
        {
            return ___registerUser(in, current);
        }
        case 34:
        {
            return ___removeCallback(in, current);
        }
        case 35:
        {
            return ___removeChannel(in, current);
        }
        case 36:
        {
            return ___removeContextCallback(in, current);
        }
        case 37:
        {
            return ___removeUserFromGroup(in, current);
        }
        case 38:
        {
            return ___sendMessage(in, current);
        }
        case 39:
        {
            return ___sendMessageChannel(in, current);
        }
        case 40:
        {
            return ___setACL(in, current);
        }
        case 41:
        {
            return ___setAuthenticator(in, current);
        }
        case 42:
        {
            return ___setBans(in, current);
        }
        case 43:
        {
            return ___setChannelState(in, current);
        }
        case 44:
        {
            return ___setConf(in, current);
        }
        case 45:
        {
            return ___setState(in, current);
        }
        case 46:
        {
            return ___setSuperuserPassword(in, current);
        }
        case 47:
        {
            return ___setTexture(in, current);
        }
        case 48:
        {
            return ___start(in, current);
        }
        case 49:
        {
            return ___stop(in, current);
        }
        case 50:
        {
            return ___unregisterUser(in, current);
        }
        case 51:
        {
            return ___updateRegistration(in, current);
        }
        case 52:
        {
            return ___verifyPassword(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::Server::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::Server::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(ServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::ServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::Server::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::MetaCallback* p) { return p; }

namespace
{
const ::std::string __Murmur__MetaCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::MetaCallback"
};

}

bool
Murmur::MetaCallback::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__MetaCallback_ids, __Murmur__MetaCallback_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::MetaCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__MetaCallback_ids[0], &__Murmur__MetaCallback_ids[2]);
}

const ::std::string&
Murmur::MetaCallback::ice_id(const ::Ice::Current&) const
{
    return __Murmur__MetaCallback_ids[1];
}

const ::std::string&
Murmur::MetaCallback::ice_staticId()
{
    return __Murmur__MetaCallback_ids[1];
}

::Ice::DispatchStatus
Murmur::MetaCallback::___started(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::ServerPrx srv;
    __is->read(srv);
    __inS.endReadParams();
    started(srv, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Murmur::MetaCallback::___stopped(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::ServerPrx srv;
    __is->read(srv);
    __inS.endReadParams();
    stopped(srv, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Murmur__MetaCallback_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "started",
    "stopped"
};

}

::Ice::DispatchStatus
Murmur::MetaCallback::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__MetaCallback_all, __Murmur__MetaCallback_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__MetaCallback_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___started(in, current);
        }
        case 5:
        {
            return ___stopped(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::MetaCallback::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::MetaCallback::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(MetaCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::MetaCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::MetaCallback::ice_staticId(), v);
    }
}

::Ice::Object* Murmur::upCast(::Murmur::Meta* p) { return p; }

namespace
{
const ::std::string __Murmur__Meta_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Meta"
};

}

bool
Murmur::Meta::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Murmur__Meta_ids, __Murmur__Meta_ids + 2, _s);
}

::std::vector< ::std::string>
Murmur::Meta::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Murmur__Meta_ids[0], &__Murmur__Meta_ids[2]);
}

const ::std::string&
Murmur::Meta::ice_id(const ::Ice::Current&) const
{
    return __Murmur__Meta_ids[1];
}

const ::std::string&
Murmur::Meta::ice_staticId()
{
    return __Murmur__Meta_ids[1];
}

::Ice::DispatchStatus
Murmur::Meta::___getServer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int id;
    __is->read(id);
    __inS.endReadParams();
    ::Murmur::AMD_Meta_getServerPtr __cb = new IceAsync::Murmur::AMD_Meta_getServer(__inS);
    try
    {
        getServer_async(__cb, id, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___newServer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_newServerPtr __cb = new IceAsync::Murmur::AMD_Meta_newServer(__inS);
    try
    {
        newServer_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getBootedServers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getBootedServersPtr __cb = new IceAsync::Murmur::AMD_Meta_getBootedServers(__inS);
    try
    {
        getBootedServers_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getAllServers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getAllServersPtr __cb = new IceAsync::Murmur::AMD_Meta_getAllServers(__inS);
    try
    {
        getAllServers_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getDefaultConf(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getDefaultConfPtr __cb = new IceAsync::Murmur::AMD_Meta_getDefaultConf(__inS);
    try
    {
        getDefaultConf_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getVersion(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getVersionPtr __cb = new IceAsync::Murmur::AMD_Meta_getVersion(__inS);
    try
    {
        getVersion_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___addCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::MetaCallbackPrx cb;
    __is->read(cb);
    __inS.endReadParams();
    ::Murmur::AMD_Meta_addCallbackPtr __cb = new IceAsync::Murmur::AMD_Meta_addCallback(__inS);
    try
    {
        addCallback_async(__cb, cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___removeCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Murmur::MetaCallbackPrx cb;
    __is->read(cb);
    __inS.endReadParams();
    ::Murmur::AMD_Meta_removeCallbackPtr __cb = new IceAsync::Murmur::AMD_Meta_removeCallback(__inS);
    try
    {
        removeCallback_async(__cb, cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getUptime(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getUptimePtr __cb = new IceAsync::Murmur::AMD_Meta_getUptime(__inS);
    try
    {
        getUptime_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getSlice(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getSlicePtr __cb = new IceAsync::Murmur::AMD_Meta_getSlice(__inS);
    try
    {
        getSlice_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
Murmur::Meta::___getSliceChecksums(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Murmur::AMD_Meta_getSliceChecksumsPtr __cb = new IceAsync::Murmur::AMD_Meta_getSliceChecksums(__inS);
    try
    {
        getSliceChecksums_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __Murmur__Meta_all[] =
{
    "addCallback",
    "getAllServers",
    "getBootedServers",
    "getDefaultConf",
    "getServer",
    "getSlice",
    "getSliceChecksums",
    "getUptime",
    "getVersion",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newServer",
    "removeCallback"
};

}

::Ice::DispatchStatus
Murmur::Meta::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Murmur__Meta_all, __Murmur__Meta_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Murmur__Meta_all)
    {
        case 0:
        {
            return ___addCallback(in, current);
        }
        case 1:
        {
            return ___getAllServers(in, current);
        }
        case 2:
        {
            return ___getBootedServers(in, current);
        }
        case 3:
        {
            return ___getDefaultConf(in, current);
        }
        case 4:
        {
            return ___getServer(in, current);
        }
        case 5:
        {
            return ___getSlice(in, current);
        }
        case 6:
        {
            return ___getSliceChecksums(in, current);
        }
        case 7:
        {
            return ___getUptime(in, current);
        }
        case 8:
        {
            return ___getVersion(in, current);
        }
        case 9:
        {
            return ___ice_id(in, current);
        }
        case 10:
        {
            return ___ice_ids(in, current);
        }
        case 11:
        {
            return ___ice_isA(in, current);
        }
        case 12:
        {
            return ___ice_ping(in, current);
        }
        case 13:
        {
            return ___newServer(in, current);
        }
        case 14:
        {
            return ___removeCallback(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Murmur::Meta::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Murmur::Meta::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Murmur::__patch(MetaPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Murmur::MetaPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Murmur::Meta::ice_staticId(), v);
    }
}
